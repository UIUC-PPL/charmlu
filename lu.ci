mainmodule lu {
  readonly CProxy_Main mainProxy;
  readonly CProxy_LUBlk luArrProxy;

  readonly int gMatSize;
  readonly ComlibInstanceHandle multicastStats[4];
  readonly int traceTrailingUpdate;
  readonly int traceComputeU;
  readonly int traceComputeL;
  readonly int traceSolveLocalLU;
  readonly int doPrioritize;
//  readonly int memThreshold;

  message blkMsg {
    double data[];
  };
	
  mainchare Main {
    entry Main(CkArgMsg *m);
    entry void finishInit();
    entry void continueIter();
    entry void arrayIsCreated(CkReductionMsg *);
    entry void outputStats();
    entry void terminateProg();
    entry void done(pathInformationMsg *m);
    entry void iterationCompleted();
  };

  array [2D] LUBlk {
    entry LUBlk(void);
    entry void init(int whichMulticastStrategy, int, int, int memThreshold);
    entry [nokeep] void updateRecvU(blkMsg *);
    entry [nokeep] void updateRecvL(blkMsg *);
    
    entry void processLocalLU(int ignoredParam);

    // These two call removeBuffered[UL], respectively, but don't
    // really reduce memory pressure, because they generate multicasts
    // along the way. Hence, not marked [memcritical]
    entry void processComputeL(int ignoredParam);
    entry void processComputeU(int ignoredParam);

    entry [memcritical] void processTrailingUpdate(int ignoredParam);

    entry void printInfo();
    entry void flushLogs();
  };        	

  group BlockCyclicMap : CkArrayMap{
    entry BlockCyclicMap();
  };

  group LUSnakeMap : CkArrayMap{
    entry LUSnakeMap(int, int);
  };

  group LUBalancedSnakeMap : CkArrayMap{
    entry LUBalancedSnakeMap(int, int);
  };

  group LUBalancedSnakeMap2 : CkArrayMap{
    entry LUBalancedSnakeMap2(int, int);
  };

};
