#ifndef _DECL_lu_H_
#define _DECL_lu_H_
#include "charm++.h"
/* DECLS: readonly CProxy_Main mainProxy;
 */

/* DECLS: readonly int traceTrailingUpdate;
 */

/* DECLS: readonly int traceComputeU;
 */

/* DECLS: readonly int traceComputeL;
 */

/* DECLS: readonly int traceSolveLocalLU;
 */


/* DECLS: message BlockReadyMsg;
 */
class BlockReadyMsg;
class CMessage_BlockReadyMsg:public CkMessage{
  public:
    static int __idx;
    void* operator new(size_t, void*p) { return p; }
    void* operator new(size_t);
    void* operator new(size_t, int*, const int);
    void* operator new(size_t, int*);
#if CMK_MULTIPLE_DELETE
    void operator delete(void*p, void*){dealloc(p);}
    void operator delete(void*p){dealloc(p);}
    void operator delete(void*p, int*, const int){dealloc(p);}
    void operator delete(void*p, int*){dealloc(p);}
#endif
    void operator delete(void*p, size_t){dealloc(p);}
    static void* alloc(int,size_t, int*, int);
    static void dealloc(void *p);
    CMessage_BlockReadyMsg();
    static void *pack(BlockReadyMsg *p);
    static BlockReadyMsg* unpack(void* p);
    void *operator new(size_t, const int);
#if CMK_MULTIPLE_DELETE
    void operator delete(void *p, const int){dealloc(p);}
#endif
    static void __register(const char *s, size_t size, CkPackFnPtr pack, CkUnpackFnPtr unpack) {
      __idx = CkRegisterMsg(s, pack, unpack, dealloc, size);
    }
};

/* DECLS: message blkMsg{
double data[];
}
;
 */
class blkMsg;
class CMessage_blkMsg:public CkMessage{
  public:
    static int __idx;
    void* operator new(size_t, void*p) { return p; }
    void* operator new(size_t);
    void* operator new(size_t, int*, const int);
    void* operator new(size_t, int*);
#if CMK_MULTIPLE_DELETE
    void operator delete(void*p, void*){dealloc(p);}
    void operator delete(void*p){dealloc(p);}
    void operator delete(void*p, int*, const int){dealloc(p);}
    void operator delete(void*p, int*){dealloc(p);}
#endif
    void operator delete(void*p, size_t){dealloc(p);}
    static void* alloc(int,size_t, int*, int);
    static void dealloc(void *p);
    CMessage_blkMsg();
    static void *pack(blkMsg *p);
    static blkMsg* unpack(void* p);
    void *operator new(size_t, int);
    void *operator new(size_t, int, const int);
#if CMK_MULTIPLE_DELETE
    void operator delete(void *p, int){dealloc(p);}
    void operator delete(void *p, int, const int){dealloc(p);}
#endif
    static void __register(const char *s, size_t size, CkPackFnPtr pack, CkUnpackFnPtr unpack) {
      __idx = CkRegisterMsg(s, pack, unpack, dealloc, size);
    }
};

/* DECLS: message UMsg{
double data[];
}
;
 */
class UMsg;
class CMessage_UMsg:public CkMessage{
  public:
    static int __idx;
    void* operator new(size_t, void*p) { return p; }
    void* operator new(size_t);
    void* operator new(size_t, int*, const int);
    void* operator new(size_t, int*);
#if CMK_MULTIPLE_DELETE
    void operator delete(void*p, void*){dealloc(p);}
    void operator delete(void*p){dealloc(p);}
    void operator delete(void*p, int*, const int){dealloc(p);}
    void operator delete(void*p, int*){dealloc(p);}
#endif
    void operator delete(void*p, size_t){dealloc(p);}
    static void* alloc(int,size_t, int*, int);
    static void dealloc(void *p);
    CMessage_UMsg();
    static void *pack(UMsg *p);
    static UMsg* unpack(void* p);
    void *operator new(size_t, int);
    void *operator new(size_t, int, const int);
#if CMK_MULTIPLE_DELETE
    void operator delete(void *p, int){dealloc(p);}
    void operator delete(void *p, int, const int){dealloc(p);}
#endif
    static void __register(const char *s, size_t size, CkPackFnPtr pack, CkUnpackFnPtr unpack) {
      __idx = CkRegisterMsg(s, pack, unpack, dealloc, size);
    }
};

/* DECLS: message pivotSequencesMsg{
int seqIndex[];
int pivotSequence[];
}
;
 */
class pivotSequencesMsg;
class CMessage_pivotSequencesMsg:public CkMessage{
  public:
    static int __idx;
    void* operator new(size_t, void*p) { return p; }
    void* operator new(size_t);
    void* operator new(size_t, int*, const int);
    void* operator new(size_t, int*);
#if CMK_MULTIPLE_DELETE
    void operator delete(void*p, void*){dealloc(p);}
    void operator delete(void*p){dealloc(p);}
    void operator delete(void*p, int*, const int){dealloc(p);}
    void operator delete(void*p, int*){dealloc(p);}
#endif
    void operator delete(void*p, size_t){dealloc(p);}
    static void* alloc(int,size_t, int*, int);
    static void dealloc(void *p);
    CMessage_pivotSequencesMsg();
    static void *pack(pivotSequencesMsg *p);
    static pivotSequencesMsg* unpack(void* p);
    void *operator new(size_t, int, int);
    void *operator new(size_t, int, int, const int);
#if CMK_MULTIPLE_DELETE
    void operator delete(void *p, int, int){dealloc(p);}
    void operator delete(void *p, int, int, const int){dealloc(p);}
#endif
    static void __register(const char *s, size_t size, CkPackFnPtr pack, CkUnpackFnPtr unpack) {
      __idx = CkRegisterMsg(s, pack, unpack, dealloc, size);
    }
};

/* DECLS: message pivotRowsMsg{
int rowNum[];
double rows[];
double rhs[];
}
;
 */
class pivotRowsMsg;
class CMessage_pivotRowsMsg:public CkMessage{
  public:
    static int __idx;
    void* operator new(size_t, void*p) { return p; }
    void* operator new(size_t);
    void* operator new(size_t, int*, const int);
    void* operator new(size_t, int*);
#if CMK_MULTIPLE_DELETE
    void operator delete(void*p, void*){dealloc(p);}
    void operator delete(void*p){dealloc(p);}
    void operator delete(void*p, int*, const int){dealloc(p);}
    void operator delete(void*p, int*){dealloc(p);}
#endif
    void operator delete(void*p, size_t){dealloc(p);}
    static void* alloc(int,size_t, int*, int);
    static void dealloc(void *p);
    CMessage_pivotRowsMsg();
    static void *pack(pivotRowsMsg *p);
    static pivotRowsMsg* unpack(void* p);
    void *operator new(size_t, int, int, int);
    void *operator new(size_t, int, int, int, const int);
#if CMK_MULTIPLE_DELETE
    void operator delete(void *p, int, int, int){dealloc(p);}
    void operator delete(void *p, int, int, int, const int){dealloc(p);}
#endif
    static void __register(const char *s, size_t size, CkPackFnPtr pack, CkUnpackFnPtr unpack) {
      __idx = CkRegisterMsg(s, pack, unpack, dealloc, size);
    }
};

/* DECLS: message rednSetupMsg;
 */
class rednSetupMsg;
class CMessage_rednSetupMsg:public CkMessage{
  public:
    static int __idx;
    void* operator new(size_t, void*p) { return p; }
    void* operator new(size_t);
    void* operator new(size_t, int*, const int);
    void* operator new(size_t, int*);
#if CMK_MULTIPLE_DELETE
    void operator delete(void*p, void*){dealloc(p);}
    void operator delete(void*p){dealloc(p);}
    void operator delete(void*p, int*, const int){dealloc(p);}
    void operator delete(void*p, int*){dealloc(p);}
#endif
    void operator delete(void*p, size_t){dealloc(p);}
    static void* alloc(int,size_t, int*, int);
    static void dealloc(void *p);
    CMessage_rednSetupMsg();
    static void *pack(rednSetupMsg *p);
    static rednSetupMsg* unpack(void* p);
    void *operator new(size_t, const int);
#if CMK_MULTIPLE_DELETE
    void operator delete(void *p, const int){dealloc(p);}
#endif
    static void __register(const char *s, size_t size, CkPackFnPtr pack, CkUnpackFnPtr unpack) {
      __idx = CkRegisterMsg(s, pack, unpack, dealloc, size);
    }
};

/* DECLS: mainchare Main: Chare{
Main(CkArgMsg* impl_msg);
void finishInit(void);
void continueIter(void);
void arrayIsCreated(void);
void outputStats(void);
void calcScaledResidual(CkReductionMsg* impl_msg);
void startNextStep(void);
};
 */
 class Main;
 class CkIndex_Main;
 class CProxy_Main;
/* --------------- index object ------------------ */
class CkIndex_Main:public CProxy_Chare{
  public:
    typedef Main local_t;
    typedef CkIndex_Main index_t;
    typedef CProxy_Main proxy_t;
    typedef CProxy_Main element_t;

    static int __idx;
    static void __register(const char *s, size_t size);
/* DECLS: Main(CkArgMsg* impl_msg);
 */
    static int __idx_Main_CkArgMsg;
    static int ckNew(CkArgMsg* impl_msg) { return __idx_Main_CkArgMsg; }
    static void _call_Main_CkArgMsg(void* impl_msg,Main* impl_obj);

/* DECLS: void finishInit(void);
 */
    static int __idx_finishInit_void;
    static int finishInit(void) { return __idx_finishInit_void; }
    static void _call_finishInit_void(void* impl_msg,Main* impl_obj);

/* DECLS: void continueIter(void);
 */
    static int __idx_continueIter_void;
    static int continueIter(void) { return __idx_continueIter_void; }
    static void _call_continueIter_void(void* impl_msg,Main* impl_obj);

/* DECLS: void arrayIsCreated(void);
 */
    static int __idx_arrayIsCreated_void;
    static int arrayIsCreated(void) { return __idx_arrayIsCreated_void; }
    static void _call_arrayIsCreated_void(void* impl_msg,Main* impl_obj);

/* DECLS: void outputStats(void);
 */
    static int __idx_outputStats_void;
    static int outputStats(void) { return __idx_outputStats_void; }
    static void _call_outputStats_void(void* impl_msg,Main* impl_obj);

/* DECLS: void calcScaledResidual(CkReductionMsg* impl_msg);
 */
    static int __idx_calcScaledResidual_CkReductionMsg;
    static int calcScaledResidual(CkReductionMsg* impl_msg) { return __idx_calcScaledResidual_CkReductionMsg; }
    static void _call_calcScaledResidual_CkReductionMsg(void* impl_msg,Main* impl_obj);

/* DECLS: void startNextStep(void);
 */
    static int __idx_startNextStep_void;
    static int startNextStep(void) { return __idx_startNextStep_void; }
    static void _call_startNextStep_void(void* impl_msg,Main* impl_obj);

};
/* --------------- element proxy ------------------ */
class CProxy_Main:public CProxy_Chare{
  public:
    typedef Main local_t;
    typedef CkIndex_Main index_t;
    typedef CProxy_Main proxy_t;
    typedef CProxy_Main element_t;

    CProxy_Main(void) {};
    CProxy_Main(CkChareID __cid) : CProxy_Chare(__cid){  }
    CProxy_Main(const Chare *c) : CProxy_Chare(c){  }
int ckIsDelegated(void) const {return CProxy_Chare::ckIsDelegated();}
inline CkDelegateMgr *ckDelegatedTo(void) const {return CProxy_Chare::ckDelegatedTo();}
inline CkDelegateData *ckDelegatedPtr(void) const {return CProxy_Chare::ckDelegatedPtr();}
CkGroupID ckDelegatedIdx(void) const {return CProxy_Chare::ckDelegatedIdx();}
inline void ckCheck(void) const {CProxy_Chare::ckCheck();}
const CkChareID &ckGetChareID(void) const
{ return CProxy_Chare::ckGetChareID(); }
operator const CkChareID &(void) const {return ckGetChareID();}
    void ckDelegate(CkDelegateMgr *dTo,CkDelegateData *dPtr=NULL) {
      CProxy_Chare::ckDelegate(dTo,dPtr);
    }
    void ckUndelegate(void) {
      CProxy_Chare::ckUndelegate();
    }
    void pup(PUP::er &p) {
      CProxy_Chare::pup(p);
    }
    void ckSetChareID(const CkChareID &c) {
      CProxy_Chare::ckSetChareID(c);
    }
    Main *ckLocal(void) const
     { return (Main *)CkLocalChare(&ckGetChareID()); }
/* DECLS: Main(CkArgMsg* impl_msg);
 */
    static CkChareID ckNew(CkArgMsg* impl_msg, int onPE=CK_PE_ANY);
    static void ckNew(CkArgMsg* impl_msg, CkChareID* pcid, int onPE=CK_PE_ANY);
    CProxy_Main(CkArgMsg* impl_msg, int onPE=CK_PE_ANY);

/* DECLS: void finishInit(void);
 */
    void finishInit(void);

/* DECLS: void continueIter(void);
 */
    void continueIter(void);

/* DECLS: void arrayIsCreated(void);
 */
    void arrayIsCreated(void);

/* DECLS: void outputStats(void);
 */
    void outputStats(void);

/* DECLS: void calcScaledResidual(CkReductionMsg* impl_msg);
 */
    void calcScaledResidual(CkReductionMsg* impl_msg);

/* DECLS: void startNextStep(void);
 */
    void startNextStep(void);

};
PUPmarshall(CProxy_Main)
typedef CBaseT1<Chare, CProxy_Main> CBase_Main;

/* DECLS: group LUMgr: IrrGroup;
 */
 class LUMgr;
 class CkIndex_LUMgr;
 class CProxy_LUMgr;
 class CProxyElement_LUMgr;
 class CProxySection_LUMgr;
/* --------------- index object ------------------ */
class CkIndex_LUMgr:public CProxyElement_IrrGroup{
  public:
    typedef LUMgr local_t;
    typedef CkIndex_LUMgr index_t;
    typedef CProxy_LUMgr proxy_t;
    typedef CProxyElement_LUMgr element_t;
    typedef CProxySection_LUMgr section_t;

    static int __idx;
    static void __register(const char *s, size_t size);
};
/* --------------- element proxy ------------------ */
class CProxyElement_LUMgr: public CProxyElement_IrrGroup{
  public:
    typedef LUMgr local_t;
    typedef CkIndex_LUMgr index_t;
    typedef CProxy_LUMgr proxy_t;
    typedef CProxyElement_LUMgr element_t;
    typedef CProxySection_LUMgr section_t;

    CProxyElement_LUMgr(void) {}
    CProxyElement_LUMgr(const IrrGroup *g) : CProxyElement_IrrGroup(g){  }
    CProxyElement_LUMgr(CkGroupID _gid,int _onPE,CK_DELCTOR_PARAM) : CProxyElement_IrrGroup(_gid,_onPE,CK_DELCTOR_ARGS){  }
    CProxyElement_LUMgr(CkGroupID _gid,int _onPE) : CProxyElement_IrrGroup(_gid,_onPE){  }
int ckIsDelegated(void) const {return CProxyElement_IrrGroup::ckIsDelegated();}
inline CkDelegateMgr *ckDelegatedTo(void) const {return CProxyElement_IrrGroup::ckDelegatedTo();}
inline CkDelegateData *ckDelegatedPtr(void) const {return CProxyElement_IrrGroup::ckDelegatedPtr();}
CkGroupID ckDelegatedIdx(void) const {return CProxyElement_IrrGroup::ckDelegatedIdx();}
inline void ckCheck(void) const {CProxyElement_IrrGroup::ckCheck();}
CkChareID ckGetChareID(void) const
   {return CProxyElement_IrrGroup::ckGetChareID();}
CkGroupID ckGetGroupID(void) const
   {return CProxyElement_IrrGroup::ckGetGroupID();}
operator CkGroupID () const { return ckGetGroupID(); }
inline void setReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxyElement_IrrGroup::setReductionClient(fn,param); }
inline void ckSetReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxyElement_IrrGroup::ckSetReductionClient(fn,param); }
inline void ckSetReductionClient(CkCallback *cb) const
{ CProxyElement_IrrGroup::ckSetReductionClient(cb); }
int ckGetGroupPe(void) const
{return CProxyElement_IrrGroup::ckGetGroupPe();}
    void ckDelegate(CkDelegateMgr *dTo,CkDelegateData *dPtr=NULL) {
      CProxyElement_IrrGroup::ckDelegate(dTo,dPtr);
    }
    void ckUndelegate(void) {
      CProxyElement_IrrGroup::ckUndelegate();
    }
    void pup(PUP::er &p) {
      CProxyElement_IrrGroup::pup(p);
    }
    void ckSetGroupID(CkGroupID g) {
      CProxyElement_IrrGroup::ckSetGroupID(g);
    }
    LUMgr* ckLocalBranch(void) const {
      return ckLocalBranch(ckGetGroupID());
    }
    static LUMgr* ckLocalBranch(CkGroupID gID) {
      return (LUMgr*)CkLocalBranch(gID);
    }
};
PUPmarshall(CProxyElement_LUMgr)
/* ---------------- collective proxy -------------- */
class CProxy_LUMgr: public CProxy_IrrGroup{
  public:
    typedef LUMgr local_t;
    typedef CkIndex_LUMgr index_t;
    typedef CProxy_LUMgr proxy_t;
    typedef CProxyElement_LUMgr element_t;
    typedef CProxySection_LUMgr section_t;

    CProxy_LUMgr(void) {}
    CProxy_LUMgr(const IrrGroup *g) : CProxy_IrrGroup(g){  }
    CProxy_LUMgr(CkGroupID _gid,CK_DELCTOR_PARAM) : CProxy_IrrGroup(_gid,CK_DELCTOR_ARGS){  }
    CProxy_LUMgr(CkGroupID _gid) : CProxy_IrrGroup(_gid){  }
    CProxyElement_LUMgr operator[](int onPE) const
      {return CProxyElement_LUMgr(ckGetGroupID(),onPE,CK_DELCTOR_CALL);}
int ckIsDelegated(void) const {return CProxy_IrrGroup::ckIsDelegated();}
inline CkDelegateMgr *ckDelegatedTo(void) const {return CProxy_IrrGroup::ckDelegatedTo();}
inline CkDelegateData *ckDelegatedPtr(void) const {return CProxy_IrrGroup::ckDelegatedPtr();}
CkGroupID ckDelegatedIdx(void) const {return CProxy_IrrGroup::ckDelegatedIdx();}
inline void ckCheck(void) const {CProxy_IrrGroup::ckCheck();}
CkChareID ckGetChareID(void) const
   {return CProxy_IrrGroup::ckGetChareID();}
CkGroupID ckGetGroupID(void) const
   {return CProxy_IrrGroup::ckGetGroupID();}
operator CkGroupID () const { return ckGetGroupID(); }
inline void setReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxy_IrrGroup::setReductionClient(fn,param); }
inline void ckSetReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxy_IrrGroup::ckSetReductionClient(fn,param); }
inline void ckSetReductionClient(CkCallback *cb) const
{ CProxy_IrrGroup::ckSetReductionClient(cb); }
    void ckDelegate(CkDelegateMgr *dTo,CkDelegateData *dPtr=NULL) {
      CProxy_IrrGroup::ckDelegate(dTo,dPtr);
    }
    void ckUndelegate(void) {
      CProxy_IrrGroup::ckUndelegate();
    }
    void pup(PUP::er &p) {
      CProxy_IrrGroup::pup(p);
    }
    void ckSetGroupID(CkGroupID g) {
      CProxy_IrrGroup::ckSetGroupID(g);
    }
    LUMgr* ckLocalBranch(void) const {
      return ckLocalBranch(ckGetGroupID());
    }
    static LUMgr* ckLocalBranch(CkGroupID gID) {
      return (LUMgr*)CkLocalBranch(gID);
    }
};
PUPmarshall(CProxy_LUMgr)
/* ---------------- section proxy -------------- */
class CProxySection_LUMgr: public CProxySection_IrrGroup{
  public:
    typedef LUMgr local_t;
    typedef CkIndex_LUMgr index_t;
    typedef CProxy_LUMgr proxy_t;
    typedef CProxyElement_LUMgr element_t;
    typedef CProxySection_LUMgr section_t;

    CProxySection_LUMgr(void) {}
    CProxySection_LUMgr(const IrrGroup *g) : CProxySection_IrrGroup(g){  }
    CProxySection_LUMgr(const CkGroupID &_gid,const int *_pelist,int _npes,CK_DELCTOR_PARAM) : CProxySection_IrrGroup(_gid,_pelist,_npes,CK_DELCTOR_ARGS){  }
    CProxySection_LUMgr(const CkGroupID &_gid,const int *_pelist,int _npes) : CProxySection_IrrGroup(_gid,_pelist,_npes){  }
    CProxySection_LUMgr(int n,const CkGroupID *_gid, int const * const *_pelist,const int *_npes) : CProxySection_IrrGroup(n,_gid,_pelist,_npes){  }
    CProxySection_LUMgr(int n,const CkGroupID *_gid, int const * const *_pelist,const int *_npes,CK_DELCTOR_PARAM) : CProxySection_IrrGroup(n,_gid,_pelist,_npes,CK_DELCTOR_ARGS){  }
int ckIsDelegated(void) const {return CProxySection_IrrGroup::ckIsDelegated();}
inline CkDelegateMgr *ckDelegatedTo(void) const {return CProxySection_IrrGroup::ckDelegatedTo();}
inline CkDelegateData *ckDelegatedPtr(void) const {return CProxySection_IrrGroup::ckDelegatedPtr();}
CkGroupID ckDelegatedIdx(void) const {return CProxySection_IrrGroup::ckDelegatedIdx();}
inline void ckCheck(void) const {CProxySection_IrrGroup::ckCheck();}
CkChareID ckGetChareID(void) const
   {return CProxySection_IrrGroup::ckGetChareID();}
CkGroupID ckGetGroupID(void) const
   {return CProxySection_IrrGroup::ckGetGroupID();}
operator CkGroupID () const { return ckGetGroupID(); }
inline void setReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxySection_IrrGroup::setReductionClient(fn,param); }
inline void ckSetReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxySection_IrrGroup::ckSetReductionClient(fn,param); }
inline void ckSetReductionClient(CkCallback *cb) const
{ CProxySection_IrrGroup::ckSetReductionClient(cb); }
inline int ckGetNumSections() const
{ return CProxySection_IrrGroup::ckGetNumSections(); }
inline CkSectionInfo &ckGetSectionInfo()
{ return CProxySection_IrrGroup::ckGetSectionInfo(); }
inline CkSectionID *ckGetSectionIDs()
{ return CProxySection_IrrGroup::ckGetSectionIDs(); }
inline CkSectionID &ckGetSectionID()
{ return CProxySection_IrrGroup::ckGetSectionID(); }
inline CkSectionID &ckGetSectionID(int i)
{ return CProxySection_IrrGroup::ckGetSectionID(i); }
inline CkGroupID ckGetGroupIDn(int i) const
{ return CProxySection_IrrGroup::ckGetGroupIDn(i); }
inline int *ckGetElements() const
{ return CProxySection_IrrGroup::ckGetElements(); }
inline int *ckGetElements(int i) const
{ return CProxySection_IrrGroup::ckGetElements(i); }
inline int ckGetNumElements() const
{ return CProxySection_IrrGroup::ckGetNumElements(); } 
inline int ckGetNumElements(int i) const
{ return CProxySection_IrrGroup::ckGetNumElements(i); }
    void ckDelegate(CkDelegateMgr *dTo,CkDelegateData *dPtr=NULL) {
      CProxySection_IrrGroup::ckDelegate(dTo,dPtr);
    }
    void ckUndelegate(void) {
      CProxySection_IrrGroup::ckUndelegate();
    }
    void pup(PUP::er &p) {
      CProxySection_IrrGroup::pup(p);
    }
    void ckSetGroupID(CkGroupID g) {
      CProxySection_IrrGroup::ckSetGroupID(g);
    }
    LUMgr* ckLocalBranch(void) const {
      return ckLocalBranch(ckGetGroupID());
    }
    static LUMgr* ckLocalBranch(CkGroupID gID) {
      return (LUMgr*)CkLocalBranch(gID);
    }
};
PUPmarshall(CProxySection_LUMgr)
typedef CBaseT1<Group, CProxy_LUMgr> CBase_LUMgr;

/* DECLS: group PrioLU: IrrGroup{
PrioLU(int BLKSIZE, int matSize);
};
 */
 class PrioLU;
 class CkIndex_PrioLU;
 class CProxy_PrioLU;
 class CProxyElement_PrioLU;
 class CProxySection_PrioLU;
/* --------------- index object ------------------ */
class CkIndex_PrioLU:public CProxyElement_IrrGroup{
  public:
    typedef PrioLU local_t;
    typedef CkIndex_PrioLU index_t;
    typedef CProxy_PrioLU proxy_t;
    typedef CProxyElement_PrioLU element_t;
    typedef CProxySection_PrioLU section_t;

    static int __idx;
    static void __register(const char *s, size_t size);
/* DECLS: PrioLU(int BLKSIZE, int matSize);
 */
    static int __idx_PrioLU_marshall1;
    static int ckNew(int BLKSIZE, int matSize) { return __idx_PrioLU_marshall1; }
    static void _call_PrioLU_marshall1(void* impl_msg,PrioLU* impl_obj);
    static int _callmarshall_PrioLU_marshall1(char* impl_buf,PrioLU* impl_obj);
    static void _marshallmessagepup_PrioLU_marshall1(PUP::er &p,void *msg);

};
/* --------------- element proxy ------------------ */
class CProxyElement_PrioLU: public CProxyElement_IrrGroup{
  public:
    typedef PrioLU local_t;
    typedef CkIndex_PrioLU index_t;
    typedef CProxy_PrioLU proxy_t;
    typedef CProxyElement_PrioLU element_t;
    typedef CProxySection_PrioLU section_t;

    CProxyElement_PrioLU(void) {}
    CProxyElement_PrioLU(const IrrGroup *g) : CProxyElement_IrrGroup(g){  }
    CProxyElement_PrioLU(CkGroupID _gid,int _onPE,CK_DELCTOR_PARAM) : CProxyElement_IrrGroup(_gid,_onPE,CK_DELCTOR_ARGS){  }
    CProxyElement_PrioLU(CkGroupID _gid,int _onPE) : CProxyElement_IrrGroup(_gid,_onPE){  }
int ckIsDelegated(void) const {return CProxyElement_IrrGroup::ckIsDelegated();}
inline CkDelegateMgr *ckDelegatedTo(void) const {return CProxyElement_IrrGroup::ckDelegatedTo();}
inline CkDelegateData *ckDelegatedPtr(void) const {return CProxyElement_IrrGroup::ckDelegatedPtr();}
CkGroupID ckDelegatedIdx(void) const {return CProxyElement_IrrGroup::ckDelegatedIdx();}
inline void ckCheck(void) const {CProxyElement_IrrGroup::ckCheck();}
CkChareID ckGetChareID(void) const
   {return CProxyElement_IrrGroup::ckGetChareID();}
CkGroupID ckGetGroupID(void) const
   {return CProxyElement_IrrGroup::ckGetGroupID();}
operator CkGroupID () const { return ckGetGroupID(); }
inline void setReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxyElement_IrrGroup::setReductionClient(fn,param); }
inline void ckSetReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxyElement_IrrGroup::ckSetReductionClient(fn,param); }
inline void ckSetReductionClient(CkCallback *cb) const
{ CProxyElement_IrrGroup::ckSetReductionClient(cb); }
int ckGetGroupPe(void) const
{return CProxyElement_IrrGroup::ckGetGroupPe();}
    void ckDelegate(CkDelegateMgr *dTo,CkDelegateData *dPtr=NULL) {
      CProxyElement_IrrGroup::ckDelegate(dTo,dPtr);
    }
    void ckUndelegate(void) {
      CProxyElement_IrrGroup::ckUndelegate();
    }
    void pup(PUP::er &p) {
      CProxyElement_IrrGroup::pup(p);
    }
    void ckSetGroupID(CkGroupID g) {
      CProxyElement_IrrGroup::ckSetGroupID(g);
    }
    PrioLU* ckLocalBranch(void) const {
      return ckLocalBranch(ckGetGroupID());
    }
    static PrioLU* ckLocalBranch(CkGroupID gID) {
      return (PrioLU*)CkLocalBranch(gID);
    }
/* DECLS: PrioLU(int BLKSIZE, int matSize);
 */

};
PUPmarshall(CProxyElement_PrioLU)
/* ---------------- collective proxy -------------- */
class CProxy_PrioLU: public CProxy_IrrGroup{
  public:
    typedef PrioLU local_t;
    typedef CkIndex_PrioLU index_t;
    typedef CProxy_PrioLU proxy_t;
    typedef CProxyElement_PrioLU element_t;
    typedef CProxySection_PrioLU section_t;

    CProxy_PrioLU(void) {}
    CProxy_PrioLU(const IrrGroup *g) : CProxy_IrrGroup(g){  }
    CProxy_PrioLU(CkGroupID _gid,CK_DELCTOR_PARAM) : CProxy_IrrGroup(_gid,CK_DELCTOR_ARGS){  }
    CProxy_PrioLU(CkGroupID _gid) : CProxy_IrrGroup(_gid){  }
    CProxyElement_PrioLU operator[](int onPE) const
      {return CProxyElement_PrioLU(ckGetGroupID(),onPE,CK_DELCTOR_CALL);}
int ckIsDelegated(void) const {return CProxy_IrrGroup::ckIsDelegated();}
inline CkDelegateMgr *ckDelegatedTo(void) const {return CProxy_IrrGroup::ckDelegatedTo();}
inline CkDelegateData *ckDelegatedPtr(void) const {return CProxy_IrrGroup::ckDelegatedPtr();}
CkGroupID ckDelegatedIdx(void) const {return CProxy_IrrGroup::ckDelegatedIdx();}
inline void ckCheck(void) const {CProxy_IrrGroup::ckCheck();}
CkChareID ckGetChareID(void) const
   {return CProxy_IrrGroup::ckGetChareID();}
CkGroupID ckGetGroupID(void) const
   {return CProxy_IrrGroup::ckGetGroupID();}
operator CkGroupID () const { return ckGetGroupID(); }
inline void setReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxy_IrrGroup::setReductionClient(fn,param); }
inline void ckSetReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxy_IrrGroup::ckSetReductionClient(fn,param); }
inline void ckSetReductionClient(CkCallback *cb) const
{ CProxy_IrrGroup::ckSetReductionClient(cb); }
    void ckDelegate(CkDelegateMgr *dTo,CkDelegateData *dPtr=NULL) {
      CProxy_IrrGroup::ckDelegate(dTo,dPtr);
    }
    void ckUndelegate(void) {
      CProxy_IrrGroup::ckUndelegate();
    }
    void pup(PUP::er &p) {
      CProxy_IrrGroup::pup(p);
    }
    void ckSetGroupID(CkGroupID g) {
      CProxy_IrrGroup::ckSetGroupID(g);
    }
    PrioLU* ckLocalBranch(void) const {
      return ckLocalBranch(ckGetGroupID());
    }
    static PrioLU* ckLocalBranch(CkGroupID gID) {
      return (PrioLU*)CkLocalBranch(gID);
    }
/* DECLS: PrioLU(int BLKSIZE, int matSize);
 */
    static CkGroupID ckNew(int BLKSIZE, int matSize, const CkEntryOptions *impl_e_opts=NULL);
    CProxy_PrioLU(int BLKSIZE, int matSize, const CkEntryOptions *impl_e_opts=NULL);

};
PUPmarshall(CProxy_PrioLU)
/* ---------------- section proxy -------------- */
class CProxySection_PrioLU: public CProxySection_IrrGroup{
  public:
    typedef PrioLU local_t;
    typedef CkIndex_PrioLU index_t;
    typedef CProxy_PrioLU proxy_t;
    typedef CProxyElement_PrioLU element_t;
    typedef CProxySection_PrioLU section_t;

    CProxySection_PrioLU(void) {}
    CProxySection_PrioLU(const IrrGroup *g) : CProxySection_IrrGroup(g){  }
    CProxySection_PrioLU(const CkGroupID &_gid,const int *_pelist,int _npes,CK_DELCTOR_PARAM) : CProxySection_IrrGroup(_gid,_pelist,_npes,CK_DELCTOR_ARGS){  }
    CProxySection_PrioLU(const CkGroupID &_gid,const int *_pelist,int _npes) : CProxySection_IrrGroup(_gid,_pelist,_npes){  }
    CProxySection_PrioLU(int n,const CkGroupID *_gid, int const * const *_pelist,const int *_npes) : CProxySection_IrrGroup(n,_gid,_pelist,_npes){  }
    CProxySection_PrioLU(int n,const CkGroupID *_gid, int const * const *_pelist,const int *_npes,CK_DELCTOR_PARAM) : CProxySection_IrrGroup(n,_gid,_pelist,_npes,CK_DELCTOR_ARGS){  }
int ckIsDelegated(void) const {return CProxySection_IrrGroup::ckIsDelegated();}
inline CkDelegateMgr *ckDelegatedTo(void) const {return CProxySection_IrrGroup::ckDelegatedTo();}
inline CkDelegateData *ckDelegatedPtr(void) const {return CProxySection_IrrGroup::ckDelegatedPtr();}
CkGroupID ckDelegatedIdx(void) const {return CProxySection_IrrGroup::ckDelegatedIdx();}
inline void ckCheck(void) const {CProxySection_IrrGroup::ckCheck();}
CkChareID ckGetChareID(void) const
   {return CProxySection_IrrGroup::ckGetChareID();}
CkGroupID ckGetGroupID(void) const
   {return CProxySection_IrrGroup::ckGetGroupID();}
operator CkGroupID () const { return ckGetGroupID(); }
inline void setReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxySection_IrrGroup::setReductionClient(fn,param); }
inline void ckSetReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxySection_IrrGroup::ckSetReductionClient(fn,param); }
inline void ckSetReductionClient(CkCallback *cb) const
{ CProxySection_IrrGroup::ckSetReductionClient(cb); }
inline int ckGetNumSections() const
{ return CProxySection_IrrGroup::ckGetNumSections(); }
inline CkSectionInfo &ckGetSectionInfo()
{ return CProxySection_IrrGroup::ckGetSectionInfo(); }
inline CkSectionID *ckGetSectionIDs()
{ return CProxySection_IrrGroup::ckGetSectionIDs(); }
inline CkSectionID &ckGetSectionID()
{ return CProxySection_IrrGroup::ckGetSectionID(); }
inline CkSectionID &ckGetSectionID(int i)
{ return CProxySection_IrrGroup::ckGetSectionID(i); }
inline CkGroupID ckGetGroupIDn(int i) const
{ return CProxySection_IrrGroup::ckGetGroupIDn(i); }
inline int *ckGetElements() const
{ return CProxySection_IrrGroup::ckGetElements(); }
inline int *ckGetElements(int i) const
{ return CProxySection_IrrGroup::ckGetElements(i); }
inline int ckGetNumElements() const
{ return CProxySection_IrrGroup::ckGetNumElements(); } 
inline int ckGetNumElements(int i) const
{ return CProxySection_IrrGroup::ckGetNumElements(i); }
    void ckDelegate(CkDelegateMgr *dTo,CkDelegateData *dPtr=NULL) {
      CProxySection_IrrGroup::ckDelegate(dTo,dPtr);
    }
    void ckUndelegate(void) {
      CProxySection_IrrGroup::ckUndelegate();
    }
    void pup(PUP::er &p) {
      CProxySection_IrrGroup::pup(p);
    }
    void ckSetGroupID(CkGroupID g) {
      CProxySection_IrrGroup::ckSetGroupID(g);
    }
    PrioLU* ckLocalBranch(void) const {
      return ckLocalBranch(ckGetGroupID());
    }
    static PrioLU* ckLocalBranch(CkGroupID gID) {
      return (PrioLU*)CkLocalBranch(gID);
    }
/* DECLS: PrioLU(int BLKSIZE, int matSize);
 */

};
PUPmarshall(CProxySection_PrioLU)
typedef CBaseT1<Group, CProxy_PrioLU> CBase_PrioLU;

class CProxy_BlockScheduler;

class LUConfig;

/* DECLS: array LUBlk: ArrayElement{
LUBlk(CkMigrateMessage* impl_msg);
LUBlk(void);
void prepareForPivotRedn(rednSetupMsg* impl_msg);
void prepareForActivePanel(rednSetupMsg* impl_msg);
void prepareForPivotLR(rednSetupMsg* impl_msg);
void prepareForRowBeforeDiag(rednSetupMsg* impl_msg);
void prepareForRowAfterDiag(rednSetupMsg* impl_msg);
void prepareForMulticastL(rednSetupMsg* impl_msg);
void multicastRedns(int dummy);
void initVec(void);
void startValidation(void);
void recvXvec(int size, const double *xvec);
void sumBvec(int size, const double *partial_b);
void colMax(CkReductionMsg* impl_msg);
void sendPivotData(int rowIndex, int pivotRow, int size, const double *data, double b);
void applyPivots(pivotSequencesMsg* impl_msg);
void acceptPivotData(pivotRowsMsg* impl_msg);
void sendUSegment(UMsg* impl_msg);
void performUpdate(int impl_noname_0);
void blockUsed(int impl_noname_1);
void getBlock(int pe);
void belowPivot(int targetCol);
void factor(void);
void processLU(void);
void beginForward(int size, const double *preVec);
void beginBackward(int size, const double *preVec);
void recvSolveData(CkReductionMsg* impl_msg);
void startup(const LUConfig &luCfg, const CProxy_LUMgr &_mgr, const CProxy_BlockScheduler &bs);
void forwardSolve(void);
void backwardSolve(void);
void recvL(blkMsg* impl_msg);
void processTrailingUpdate(int step, const intptr_t &update_ptr);
void processComputeU(int ignoredParam);
void flushLogs(void);
void print(void);
};
 */
 class LUBlk;
 class CkIndex_LUBlk;
 class CProxy_LUBlk;
 class CProxyElement_LUBlk;
 class CProxySection_LUBlk;
/* --------------- index object ------------------ */
class CkIndex_LUBlk:public CProxyElement_ArrayElement{
  public:
    typedef LUBlk local_t;
    typedef CkIndex_LUBlk index_t;
    typedef CProxy_LUBlk proxy_t;
    typedef CProxyElement_LUBlk element_t;
    typedef CProxySection_LUBlk section_t;

    static int __idx;
    static void __register(const char *s, size_t size);
/* DECLS: LUBlk(CkMigrateMessage* impl_msg);
 */
    static int __idx_LUBlk_CkMigrateMessage;
    static int ckNew(CkMigrateMessage* impl_msg) { return __idx_LUBlk_CkMigrateMessage; }
    static void _call_LUBlk_CkMigrateMessage(void* impl_msg,LUBlk* impl_obj);

/* DECLS: LUBlk(void);
 */
    static int __idx_LUBlk_void;
    static int ckNew(void) { return __idx_LUBlk_void; }
    static void _call_LUBlk_void(void* impl_msg,LUBlk* impl_obj);

/* DECLS: void prepareForPivotRedn(rednSetupMsg* impl_msg);
 */
    static int __idx_prepareForPivotRedn_rednSetupMsg;
    static int prepareForPivotRedn(rednSetupMsg* impl_msg) { return __idx_prepareForPivotRedn_rednSetupMsg; }
    static void _call_prepareForPivotRedn_rednSetupMsg(void* impl_msg,LUBlk* impl_obj);

/* DECLS: void prepareForActivePanel(rednSetupMsg* impl_msg);
 */
    static int __idx_prepareForActivePanel_rednSetupMsg;
    static int prepareForActivePanel(rednSetupMsg* impl_msg) { return __idx_prepareForActivePanel_rednSetupMsg; }
    static void _call_prepareForActivePanel_rednSetupMsg(void* impl_msg,LUBlk* impl_obj);

/* DECLS: void prepareForPivotLR(rednSetupMsg* impl_msg);
 */
    static int __idx_prepareForPivotLR_rednSetupMsg;
    static int prepareForPivotLR(rednSetupMsg* impl_msg) { return __idx_prepareForPivotLR_rednSetupMsg; }
    static void _call_prepareForPivotLR_rednSetupMsg(void* impl_msg,LUBlk* impl_obj);

/* DECLS: void prepareForRowBeforeDiag(rednSetupMsg* impl_msg);
 */
    static int __idx_prepareForRowBeforeDiag_rednSetupMsg;
    static int prepareForRowBeforeDiag(rednSetupMsg* impl_msg) { return __idx_prepareForRowBeforeDiag_rednSetupMsg; }
    static void _call_prepareForRowBeforeDiag_rednSetupMsg(void* impl_msg,LUBlk* impl_obj);

/* DECLS: void prepareForRowAfterDiag(rednSetupMsg* impl_msg);
 */
    static int __idx_prepareForRowAfterDiag_rednSetupMsg;
    static int prepareForRowAfterDiag(rednSetupMsg* impl_msg) { return __idx_prepareForRowAfterDiag_rednSetupMsg; }
    static void _call_prepareForRowAfterDiag_rednSetupMsg(void* impl_msg,LUBlk* impl_obj);

/* DECLS: void prepareForMulticastL(rednSetupMsg* impl_msg);
 */
    static int __idx_prepareForMulticastL_rednSetupMsg;
    static int prepareForMulticastL(rednSetupMsg* impl_msg) { return __idx_prepareForMulticastL_rednSetupMsg; }
    static void _call_prepareForMulticastL_rednSetupMsg(void* impl_msg,LUBlk* impl_obj);

/* DECLS: void multicastRedns(int dummy);
 */
    static int __idx_multicastRedns_marshall8;
    static int multicastRedns(int dummy) { return __idx_multicastRedns_marshall8; }
    static void _call_multicastRedns_marshall8(void* impl_msg,LUBlk* impl_obj);
    static int _callmarshall_multicastRedns_marshall8(char* impl_buf,LUBlk* impl_obj);
    static void _marshallmessagepup_multicastRedns_marshall8(PUP::er &p,void *msg);

/* DECLS: void initVec(void);
 */
    static int __idx_initVec_void;
    static int initVec(void) { return __idx_initVec_void; }
    static void _call_initVec_void(void* impl_msg,LUBlk* impl_obj);

/* DECLS: void startValidation(void);
 */
    static int __idx_startValidation_void;
    static int startValidation(void) { return __idx_startValidation_void; }
    static void _call_startValidation_void(void* impl_msg,LUBlk* impl_obj);

/* DECLS: void recvXvec(int size, const double *xvec);
 */
    static int __idx_recvXvec_marshall11;
    static int recvXvec(int size, const double *xvec) { return __idx_recvXvec_marshall11; }
    static void _call_recvXvec_marshall11(void* impl_msg,LUBlk* impl_obj);
    static int _callmarshall_recvXvec_marshall11(char* impl_buf,LUBlk* impl_obj);
    static void _marshallmessagepup_recvXvec_marshall11(PUP::er &p,void *msg);

/* DECLS: void sumBvec(int size, const double *partial_b);
 */
    static int __idx_sumBvec_marshall12;
    static int sumBvec(int size, const double *partial_b) { return __idx_sumBvec_marshall12; }
    static void _call_sumBvec_marshall12(void* impl_msg,LUBlk* impl_obj);
    static int _callmarshall_sumBvec_marshall12(char* impl_buf,LUBlk* impl_obj);
    static void _marshallmessagepup_sumBvec_marshall12(PUP::er &p,void *msg);

/* DECLS: void colMax(CkReductionMsg* impl_msg);
 */
    static int __idx_colMax_CkReductionMsg;
    static int colMax(CkReductionMsg* impl_msg) { return __idx_colMax_CkReductionMsg; }
    static void _call_colMax_CkReductionMsg(void* impl_msg,LUBlk* impl_obj);

/* DECLS: void sendPivotData(int rowIndex, int pivotRow, int size, const double *data, double b);
 */
    static int __idx_sendPivotData_marshall14;
    static int sendPivotData(int rowIndex, int pivotRow, int size, const double *data, double b) { return __idx_sendPivotData_marshall14; }
    static void _call_sendPivotData_marshall14(void* impl_msg,LUBlk* impl_obj);
    static int _callmarshall_sendPivotData_marshall14(char* impl_buf,LUBlk* impl_obj);
    static void _marshallmessagepup_sendPivotData_marshall14(PUP::er &p,void *msg);

/* DECLS: void applyPivots(pivotSequencesMsg* impl_msg);
 */
    static int __idx_applyPivots_pivotSequencesMsg;
    static int applyPivots(pivotSequencesMsg* impl_msg) { return __idx_applyPivots_pivotSequencesMsg; }
    static void _call_applyPivots_pivotSequencesMsg(void* impl_msg,LUBlk* impl_obj);

/* DECLS: void acceptPivotData(pivotRowsMsg* impl_msg);
 */
    static int __idx_acceptPivotData_pivotRowsMsg;
    static int acceptPivotData(pivotRowsMsg* impl_msg) { return __idx_acceptPivotData_pivotRowsMsg; }
    static void _call_acceptPivotData_pivotRowsMsg(void* impl_msg,LUBlk* impl_obj);

/* DECLS: void sendUSegment(UMsg* impl_msg);
 */
    static int __idx_sendUSegment_UMsg;
    static int sendUSegment(UMsg* impl_msg) { return __idx_sendUSegment_UMsg; }
    static void _call_sendUSegment_UMsg(void* impl_msg,LUBlk* impl_obj);

/* DECLS: void performUpdate(int impl_noname_0);
 */
    static int __idx_performUpdate_marshall18;
    static int performUpdate(int impl_noname_0) { return __idx_performUpdate_marshall18; }
    static void _call_performUpdate_marshall18(void* impl_msg,LUBlk* impl_obj);
    static int _callmarshall_performUpdate_marshall18(char* impl_buf,LUBlk* impl_obj);
    static void _marshallmessagepup_performUpdate_marshall18(PUP::er &p,void *msg);

/* DECLS: void blockUsed(int impl_noname_1);
 */
    static int __idx_blockUsed_marshall19;
    static int blockUsed(int impl_noname_1) { return __idx_blockUsed_marshall19; }
    static void _call_blockUsed_marshall19(void* impl_msg,LUBlk* impl_obj);
    static int _callmarshall_blockUsed_marshall19(char* impl_buf,LUBlk* impl_obj);
    static void _marshallmessagepup_blockUsed_marshall19(PUP::er &p,void *msg);

/* DECLS: void getBlock(int pe);
 */
    static int __idx_getBlock_marshall20;
    static int getBlock(int pe) { return __idx_getBlock_marshall20; }
    static void _call_getBlock_marshall20(void* impl_msg,LUBlk* impl_obj);
    static int _callmarshall_getBlock_marshall20(char* impl_buf,LUBlk* impl_obj);
    static void _marshallmessagepup_getBlock_marshall20(PUP::er &p,void *msg);

/* DECLS: void belowPivot(int targetCol);
 */
    static int __idx_belowPivot_marshall21;
    static int belowPivot(int targetCol) { return __idx_belowPivot_marshall21; }
    static void _call_belowPivot_marshall21(void* impl_msg,LUBlk* impl_obj);
    static int _callmarshall_belowPivot_marshall21(char* impl_buf,LUBlk* impl_obj);
    static void _marshallmessagepup_belowPivot_marshall21(PUP::er &p,void *msg);

/* DECLS: void factor(void);
 */
    static int __idx_factor_void;
    static int factor(void) { return __idx_factor_void; }
    static void _call_factor_void(void* impl_msg,LUBlk* impl_obj);

/* DECLS: void processLU(void);
 */
    static int __idx_processLU_void;
    static int processLU(void) { return __idx_processLU_void; }
    static void _call_processLU_void(void* impl_msg,LUBlk* impl_obj);

/* DECLS: void beginForward(int size, const double *preVec);
 */
    static int __idx_beginForward_marshall24;
    static int beginForward(int size, const double *preVec) { return __idx_beginForward_marshall24; }
    static void _call_beginForward_marshall24(void* impl_msg,LUBlk* impl_obj);
    static int _callmarshall_beginForward_marshall24(char* impl_buf,LUBlk* impl_obj);
    static void _marshallmessagepup_beginForward_marshall24(PUP::er &p,void *msg);

/* DECLS: void beginBackward(int size, const double *preVec);
 */
    static int __idx_beginBackward_marshall25;
    static int beginBackward(int size, const double *preVec) { return __idx_beginBackward_marshall25; }
    static void _call_beginBackward_marshall25(void* impl_msg,LUBlk* impl_obj);
    static int _callmarshall_beginBackward_marshall25(char* impl_buf,LUBlk* impl_obj);
    static void _marshallmessagepup_beginBackward_marshall25(PUP::er &p,void *msg);

/* DECLS: void recvSolveData(CkReductionMsg* impl_msg);
 */
    static int __idx_recvSolveData_CkReductionMsg;
    static int recvSolveData(CkReductionMsg* impl_msg) { return __idx_recvSolveData_CkReductionMsg; }
    static void _call_recvSolveData_CkReductionMsg(void* impl_msg,LUBlk* impl_obj);

/* DECLS: void startup(const LUConfig &luCfg, const CProxy_LUMgr &_mgr, const CProxy_BlockScheduler &bs);
 */
    static int __idx_startup_marshall27;
    static int startup(const LUConfig &luCfg, const CProxy_LUMgr &_mgr, const CProxy_BlockScheduler &bs) { return __idx_startup_marshall27; }
    static void _call_startup_marshall27(void* impl_msg,LUBlk* impl_obj);
    static int _callmarshall_startup_marshall27(char* impl_buf,LUBlk* impl_obj);
    static void _marshallmessagepup_startup_marshall27(PUP::er &p,void *msg);

/* DECLS: void forwardSolve(void);
 */
    static int __idx_forwardSolve_void;
    static int forwardSolve(void) { return __idx_forwardSolve_void; }
    static void _call_forwardSolve_void(void* impl_msg,LUBlk* impl_obj);

/* DECLS: void backwardSolve(void);
 */
    static int __idx_backwardSolve_void;
    static int backwardSolve(void) { return __idx_backwardSolve_void; }
    static void _call_backwardSolve_void(void* impl_msg,LUBlk* impl_obj);

/* DECLS: void recvL(blkMsg* impl_msg);
 */
    static int __idx_recvL_blkMsg;
    static int recvL(blkMsg* impl_msg) { return __idx_recvL_blkMsg; }
    static void _call_recvL_blkMsg(void* impl_msg,LUBlk* impl_obj);

/* DECLS: void processTrailingUpdate(int step, const intptr_t &update_ptr);
 */
    static int __idx_processTrailingUpdate_marshall31;
    static int processTrailingUpdate(int step, const intptr_t &update_ptr) { return __idx_processTrailingUpdate_marshall31; }
    static void _call_processTrailingUpdate_marshall31(void* impl_msg,LUBlk* impl_obj);
    static int _callmarshall_processTrailingUpdate_marshall31(char* impl_buf,LUBlk* impl_obj);
    static void _marshallmessagepup_processTrailingUpdate_marshall31(PUP::er &p,void *msg);

/* DECLS: void processComputeU(int ignoredParam);
 */
    static int __idx_processComputeU_marshall32;
    static int processComputeU(int ignoredParam) { return __idx_processComputeU_marshall32; }
    static void _call_processComputeU_marshall32(void* impl_msg,LUBlk* impl_obj);
    static int _callmarshall_processComputeU_marshall32(char* impl_buf,LUBlk* impl_obj);
    static void _marshallmessagepup_processComputeU_marshall32(PUP::er &p,void *msg);

/* DECLS: void flushLogs(void);
 */
    static int __idx_flushLogs_void;
    static int flushLogs(void) { return __idx_flushLogs_void; }
    static void _call_flushLogs_void(void* impl_msg,LUBlk* impl_obj);

/* DECLS: void print(void);
 */
    static int __idx_print_void;
    static int print(void) { return __idx_print_void; }
    static void _call_print_void(void* impl_msg,LUBlk* impl_obj);

};
/* --------------- element proxy ------------------ */
 class CProxyElement_LUBlk : public CProxyElement_ArrayElement{
  public:
    typedef LUBlk local_t;
    typedef CkIndex_LUBlk index_t;
    typedef CProxy_LUBlk proxy_t;
    typedef CProxyElement_LUBlk element_t;
    typedef CProxySection_LUBlk section_t;

    CProxyElement_LUBlk(void) {}
    CProxyElement_LUBlk(const ArrayElement *e) : CProxyElement_ArrayElement(e){  }
    void ckDelegate(CkDelegateMgr *dTo,CkDelegateData *dPtr=NULL) {
      CProxyElement_ArrayElement::ckDelegate(dTo,dPtr);
    }
    void ckUndelegate(void) {
      CProxyElement_ArrayElement::ckUndelegate();
    }
    void pup(PUP::er &p) {
      CProxyElement_ArrayElement::pup(p);
    }
int ckIsDelegated(void) const {return CProxyElement_ArrayElement::ckIsDelegated();}
inline CkDelegateMgr *ckDelegatedTo(void) const {return CProxyElement_ArrayElement::ckDelegatedTo();}
inline CkDelegateData *ckDelegatedPtr(void) const {return CProxyElement_ArrayElement::ckDelegatedPtr();}
CkGroupID ckDelegatedIdx(void) const {return CProxyElement_ArrayElement::ckDelegatedIdx();}
inline void ckCheck(void) const {CProxyElement_ArrayElement::ckCheck();}
inline operator CkArrayID () const {return ckGetArrayID();}
inline static CkArrayID ckCreateEmptyArray(void){ return CProxyElement_ArrayElement::ckCreateEmptyArray(); }
inline static CkArrayID ckCreateArray(CkArrayMessage *m,int ctor,const CkArrayOptions &opts){ return CProxyElement_ArrayElement::ckCreateArray(m,ctor,opts); }
inline void ckInsertIdx(CkArrayMessage *m,int ctor,int onPe,const CkArrayIndex &idx){ CProxyElement_ArrayElement::ckInsertIdx(m,ctor,onPe,idx); }
inline void ckBroadcast(CkArrayMessage *m, int ep, int opts=0) const{ CProxyElement_ArrayElement::ckBroadcast(m,ep,opts); }
inline CkArrayID ckGetArrayID(void) const{ return CProxyElement_ArrayElement::ckGetArrayID();}
inline CkArray *ckLocalBranch(void) const{ return CProxyElement_ArrayElement::ckLocalBranch(); }
inline CkLocMgr *ckLocMgr(void) const{ return CProxyElement_ArrayElement::ckLocMgr(); }
inline void doneInserting(void) { CProxyElement_ArrayElement::doneInserting(); }
inline void setReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxyElement_ArrayElement::setReductionClient(fn,param); }
inline void ckSetReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxyElement_ArrayElement::ckSetReductionClient(fn,param); }
inline void ckSetReductionClient(CkCallback *cb) const
{ CProxyElement_ArrayElement::ckSetReductionClient(cb); }
inline void ckInsert(CkArrayMessage *m,int ctor,int onPe)
  { CProxyElement_ArrayElement::ckInsert(m,ctor,onPe); }
inline void ckSend(CkArrayMessage *m, int ep, int opts = 0) const
  { CProxyElement_ArrayElement::ckSend(m,ep,opts); }
inline void *ckSendSync(CkArrayMessage *m, int ep) const
  { return CProxyElement_ArrayElement::ckSendSync(m,ep); }
inline const CkArrayIndex &ckGetIndex() const
  { return CProxyElement_ArrayElement::ckGetIndex(); }
    LUBlk *ckLocal(void) const
      { return (LUBlk *)CProxyElement_ArrayElement::ckLocal(); }
    CProxyElement_LUBlk(const CkArrayID &aid,const CkArrayIndex2D &idx,CK_DELCTOR_PARAM)
        :CProxyElement_ArrayElement(aid,idx,CK_DELCTOR_ARGS) {}
    CProxyElement_LUBlk(const CkArrayID &aid,const CkArrayIndex2D &idx)
        :CProxyElement_ArrayElement(aid,idx) {}
/* DECLS: LUBlk(CkMigrateMessage* impl_msg);
 */

/* DECLS: LUBlk(void);
 */
    void insert(int onPE=-1);
/* DECLS: void prepareForPivotRedn(rednSetupMsg* impl_msg);
 */
    void prepareForPivotRedn(rednSetupMsg* impl_msg) ;

/* DECLS: void prepareForActivePanel(rednSetupMsg* impl_msg);
 */
    void prepareForActivePanel(rednSetupMsg* impl_msg) ;

/* DECLS: void prepareForPivotLR(rednSetupMsg* impl_msg);
 */
    void prepareForPivotLR(rednSetupMsg* impl_msg) ;

/* DECLS: void prepareForRowBeforeDiag(rednSetupMsg* impl_msg);
 */
    void prepareForRowBeforeDiag(rednSetupMsg* impl_msg) ;

/* DECLS: void prepareForRowAfterDiag(rednSetupMsg* impl_msg);
 */
    void prepareForRowAfterDiag(rednSetupMsg* impl_msg) ;

/* DECLS: void prepareForMulticastL(rednSetupMsg* impl_msg);
 */
    void prepareForMulticastL(rednSetupMsg* impl_msg) ;

/* DECLS: void multicastRedns(int dummy);
 */
    void multicastRedns(int dummy, const CkEntryOptions *impl_e_opts=NULL) ;

/* DECLS: void initVec(void);
 */
    void initVec(void) ;

/* DECLS: void startValidation(void);
 */
    void startValidation(void) ;

/* DECLS: void recvXvec(int size, const double *xvec);
 */
    void recvXvec(int size, const double *xvec, const CkEntryOptions *impl_e_opts=NULL) ;

/* DECLS: void sumBvec(int size, const double *partial_b);
 */
    void sumBvec(int size, const double *partial_b, const CkEntryOptions *impl_e_opts=NULL) ;

/* DECLS: void colMax(CkReductionMsg* impl_msg);
 */
    void colMax(CkReductionMsg* impl_msg) ;

/* DECLS: void sendPivotData(int rowIndex, int pivotRow, int size, const double *data, double b);
 */
    void sendPivotData(int rowIndex, int pivotRow, int size, const double *data, double b, const CkEntryOptions *impl_e_opts=NULL) ;

/* DECLS: void applyPivots(pivotSequencesMsg* impl_msg);
 */
    void applyPivots(pivotSequencesMsg* impl_msg) ;

/* DECLS: void acceptPivotData(pivotRowsMsg* impl_msg);
 */
    void acceptPivotData(pivotRowsMsg* impl_msg) ;

/* DECLS: void sendUSegment(UMsg* impl_msg);
 */
    void sendUSegment(UMsg* impl_msg) ;

/* DECLS: void performUpdate(int impl_noname_0);
 */
    void performUpdate(int impl_noname_0, const CkEntryOptions *impl_e_opts=NULL) ;

/* DECLS: void blockUsed(int impl_noname_1);
 */
    void blockUsed(int impl_noname_1, const CkEntryOptions *impl_e_opts=NULL) ;

/* DECLS: void getBlock(int pe);
 */
    void getBlock(int pe, const CkEntryOptions *impl_e_opts=NULL) ;

/* DECLS: void belowPivot(int targetCol);
 */
    void belowPivot(int targetCol, const CkEntryOptions *impl_e_opts=NULL) ;

/* DECLS: void factor(void);
 */
    void factor(void) ;

/* DECLS: void processLU(void);
 */
    void processLU(void) ;

/* DECLS: void beginForward(int size, const double *preVec);
 */
    void beginForward(int size, const double *preVec, const CkEntryOptions *impl_e_opts=NULL) ;

/* DECLS: void beginBackward(int size, const double *preVec);
 */
    void beginBackward(int size, const double *preVec, const CkEntryOptions *impl_e_opts=NULL) ;

/* DECLS: void recvSolveData(CkReductionMsg* impl_msg);
 */
    void recvSolveData(CkReductionMsg* impl_msg) ;

/* DECLS: void startup(const LUConfig &luCfg, const CProxy_LUMgr &_mgr, const CProxy_BlockScheduler &bs);
 */
    void startup(const LUConfig &luCfg, const CProxy_LUMgr &_mgr, const CProxy_BlockScheduler &bs, const CkEntryOptions *impl_e_opts=NULL) ;

/* DECLS: void forwardSolve(void);
 */
    void forwardSolve(void) ;

/* DECLS: void backwardSolve(void);
 */
    void backwardSolve(void) ;

/* DECLS: void recvL(blkMsg* impl_msg);
 */
    void recvL(blkMsg* impl_msg) ;

/* DECLS: void processTrailingUpdate(int step, const intptr_t &update_ptr);
 */
    void processTrailingUpdate(int step, intptr_t &update_ptr, const CkEntryOptions *impl_e_opts=NULL) ;

/* DECLS: void processComputeU(int ignoredParam);
 */
    void processComputeU(int ignoredParam, const CkEntryOptions *impl_e_opts=NULL) ;

/* DECLS: void flushLogs(void);
 */
    void flushLogs(void) ;

/* DECLS: void print(void);
 */
    void print(void) ;

};
PUPmarshall(CProxyElement_LUBlk)
/* ---------------- collective proxy -------------- */
 class CProxy_LUBlk : public CProxy_ArrayElement{
  public:
    typedef LUBlk local_t;
    typedef CkIndex_LUBlk index_t;
    typedef CProxy_LUBlk proxy_t;
    typedef CProxyElement_LUBlk element_t;
    typedef CProxySection_LUBlk section_t;

    CProxy_LUBlk(void) {}
    CProxy_LUBlk(const ArrayElement *e) : CProxy_ArrayElement(e){  }
    void ckDelegate(CkDelegateMgr *dTo,CkDelegateData *dPtr=NULL) {
      CProxy_ArrayElement::ckDelegate(dTo,dPtr);
    }
    void ckUndelegate(void) {
      CProxy_ArrayElement::ckUndelegate();
    }
    void pup(PUP::er &p) {
      CProxy_ArrayElement::pup(p);
    }
int ckIsDelegated(void) const {return CProxy_ArrayElement::ckIsDelegated();}
inline CkDelegateMgr *ckDelegatedTo(void) const {return CProxy_ArrayElement::ckDelegatedTo();}
inline CkDelegateData *ckDelegatedPtr(void) const {return CProxy_ArrayElement::ckDelegatedPtr();}
CkGroupID ckDelegatedIdx(void) const {return CProxy_ArrayElement::ckDelegatedIdx();}
inline void ckCheck(void) const {CProxy_ArrayElement::ckCheck();}
inline operator CkArrayID () const {return ckGetArrayID();}
inline static CkArrayID ckCreateEmptyArray(void){ return CProxy_ArrayElement::ckCreateEmptyArray(); }
inline static CkArrayID ckCreateArray(CkArrayMessage *m,int ctor,const CkArrayOptions &opts){ return CProxy_ArrayElement::ckCreateArray(m,ctor,opts); }
inline void ckInsertIdx(CkArrayMessage *m,int ctor,int onPe,const CkArrayIndex &idx){ CProxy_ArrayElement::ckInsertIdx(m,ctor,onPe,idx); }
inline void ckBroadcast(CkArrayMessage *m, int ep, int opts=0) const{ CProxy_ArrayElement::ckBroadcast(m,ep,opts); }
inline CkArrayID ckGetArrayID(void) const{ return CProxy_ArrayElement::ckGetArrayID();}
inline CkArray *ckLocalBranch(void) const{ return CProxy_ArrayElement::ckLocalBranch(); }
inline CkLocMgr *ckLocMgr(void) const{ return CProxy_ArrayElement::ckLocMgr(); }
inline void doneInserting(void) { CProxy_ArrayElement::doneInserting(); }
inline void setReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxy_ArrayElement::setReductionClient(fn,param); }
inline void ckSetReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxy_ArrayElement::ckSetReductionClient(fn,param); }
inline void ckSetReductionClient(CkCallback *cb) const
{ CProxy_ArrayElement::ckSetReductionClient(cb); }
    static CkArrayID ckNew(void) {return ckCreateEmptyArray();}
//Generalized array indexing:
    CProxyElement_LUBlk operator [] (const CkArrayIndex2D &idx) const
        {return CProxyElement_LUBlk(ckGetArrayID(), idx, CK_DELCTOR_CALL);}
    CProxyElement_LUBlk operator() (const CkArrayIndex2D &idx) const
        {return CProxyElement_LUBlk(ckGetArrayID(), idx, CK_DELCTOR_CALL);}
    CProxyElement_LUBlk operator () (int i0,int i1) const 
        {return CProxyElement_LUBlk(ckGetArrayID(), CkArrayIndex2D(i0,i1), CK_DELCTOR_CALL);}
    CProxyElement_LUBlk operator () (CkIndex2D idx) const 
        {return CProxyElement_LUBlk(ckGetArrayID(), CkArrayIndex2D(idx), CK_DELCTOR_CALL);}
    CProxy_LUBlk(const CkArrayID &aid,CK_DELCTOR_PARAM) 
        :CProxy_ArrayElement(aid,CK_DELCTOR_ARGS) {}
    CProxy_LUBlk(const CkArrayID &aid) 
        :CProxy_ArrayElement(aid) {}
/* DECLS: LUBlk(CkMigrateMessage* impl_msg);
 */

/* DECLS: LUBlk(void);
 */
    static CkArrayID ckNew(const CkArrayOptions &opts);
    static CkArrayID ckNew(const int s1, const int s2);

/* DECLS: void prepareForPivotRedn(rednSetupMsg* impl_msg);
 */
    void prepareForPivotRedn(rednSetupMsg* impl_msg) ;

/* DECLS: void prepareForActivePanel(rednSetupMsg* impl_msg);
 */
    void prepareForActivePanel(rednSetupMsg* impl_msg) ;

/* DECLS: void prepareForPivotLR(rednSetupMsg* impl_msg);
 */
    void prepareForPivotLR(rednSetupMsg* impl_msg) ;

/* DECLS: void prepareForRowBeforeDiag(rednSetupMsg* impl_msg);
 */
    void prepareForRowBeforeDiag(rednSetupMsg* impl_msg) ;

/* DECLS: void prepareForRowAfterDiag(rednSetupMsg* impl_msg);
 */
    void prepareForRowAfterDiag(rednSetupMsg* impl_msg) ;

/* DECLS: void prepareForMulticastL(rednSetupMsg* impl_msg);
 */
    void prepareForMulticastL(rednSetupMsg* impl_msg) ;

/* DECLS: void multicastRedns(int dummy);
 */
    void multicastRedns(int dummy, const CkEntryOptions *impl_e_opts=NULL) ;

/* DECLS: void initVec(void);
 */
    void initVec(void) ;

/* DECLS: void startValidation(void);
 */
    void startValidation(void) ;

/* DECLS: void recvXvec(int size, const double *xvec);
 */
    void recvXvec(int size, const double *xvec, const CkEntryOptions *impl_e_opts=NULL) ;

/* DECLS: void sumBvec(int size, const double *partial_b);
 */
    void sumBvec(int size, const double *partial_b, const CkEntryOptions *impl_e_opts=NULL) ;

/* DECLS: void colMax(CkReductionMsg* impl_msg);
 */
    void colMax(CkReductionMsg* impl_msg) ;

/* DECLS: void sendPivotData(int rowIndex, int pivotRow, int size, const double *data, double b);
 */
    void sendPivotData(int rowIndex, int pivotRow, int size, const double *data, double b, const CkEntryOptions *impl_e_opts=NULL) ;

/* DECLS: void applyPivots(pivotSequencesMsg* impl_msg);
 */
    void applyPivots(pivotSequencesMsg* impl_msg) ;

/* DECLS: void acceptPivotData(pivotRowsMsg* impl_msg);
 */
    void acceptPivotData(pivotRowsMsg* impl_msg) ;

/* DECLS: void sendUSegment(UMsg* impl_msg);
 */
    void sendUSegment(UMsg* impl_msg) ;

/* DECLS: void performUpdate(int impl_noname_0);
 */
    void performUpdate(int impl_noname_0, const CkEntryOptions *impl_e_opts=NULL) ;

/* DECLS: void blockUsed(int impl_noname_1);
 */
    void blockUsed(int impl_noname_1, const CkEntryOptions *impl_e_opts=NULL) ;

/* DECLS: void getBlock(int pe);
 */
    void getBlock(int pe, const CkEntryOptions *impl_e_opts=NULL) ;

/* DECLS: void belowPivot(int targetCol);
 */
    void belowPivot(int targetCol, const CkEntryOptions *impl_e_opts=NULL) ;

/* DECLS: void factor(void);
 */
    void factor(void) ;

/* DECLS: void processLU(void);
 */
    void processLU(void) ;

/* DECLS: void beginForward(int size, const double *preVec);
 */
    void beginForward(int size, const double *preVec, const CkEntryOptions *impl_e_opts=NULL) ;

/* DECLS: void beginBackward(int size, const double *preVec);
 */
    void beginBackward(int size, const double *preVec, const CkEntryOptions *impl_e_opts=NULL) ;

/* DECLS: void recvSolveData(CkReductionMsg* impl_msg);
 */
    void recvSolveData(CkReductionMsg* impl_msg) ;

/* DECLS: void startup(const LUConfig &luCfg, const CProxy_LUMgr &_mgr, const CProxy_BlockScheduler &bs);
 */
    void startup(const LUConfig &luCfg, const CProxy_LUMgr &_mgr, const CProxy_BlockScheduler &bs, const CkEntryOptions *impl_e_opts=NULL) ;

/* DECLS: void forwardSolve(void);
 */
    void forwardSolve(void) ;

/* DECLS: void backwardSolve(void);
 */
    void backwardSolve(void) ;

/* DECLS: void recvL(blkMsg* impl_msg);
 */
    void recvL(blkMsg* impl_msg) ;

/* DECLS: void processTrailingUpdate(int step, const intptr_t &update_ptr);
 */

/* DECLS: void processComputeU(int ignoredParam);
 */
    void processComputeU(int ignoredParam, const CkEntryOptions *impl_e_opts=NULL) ;

/* DECLS: void flushLogs(void);
 */
    void flushLogs(void) ;

/* DECLS: void print(void);
 */
    void print(void) ;

};
PUPmarshall(CProxy_LUBlk)
/* ---------------- section proxy -------------- */
 class CProxySection_LUBlk : public CProxySection_ArrayElement{
  public:
    typedef LUBlk local_t;
    typedef CkIndex_LUBlk index_t;
    typedef CProxy_LUBlk proxy_t;
    typedef CProxyElement_LUBlk element_t;
    typedef CProxySection_LUBlk section_t;

    CProxySection_LUBlk(void) {}
    void ckDelegate(CkDelegateMgr *dTo,CkDelegateData *dPtr=NULL) {
      CProxySection_ArrayElement::ckDelegate(dTo,dPtr);
    }
    void ckUndelegate(void) {
      CProxySection_ArrayElement::ckUndelegate();
    }
    void pup(PUP::er &p) {
      CProxySection_ArrayElement::pup(p);
    }
int ckIsDelegated(void) const {return CProxySection_ArrayElement::ckIsDelegated();}
inline CkDelegateMgr *ckDelegatedTo(void) const {return CProxySection_ArrayElement::ckDelegatedTo();}
inline CkDelegateData *ckDelegatedPtr(void) const {return CProxySection_ArrayElement::ckDelegatedPtr();}
CkGroupID ckDelegatedIdx(void) const {return CProxySection_ArrayElement::ckDelegatedIdx();}
inline void ckCheck(void) const {CProxySection_ArrayElement::ckCheck();}
inline operator CkArrayID () const {return ckGetArrayID();}
inline static CkArrayID ckCreateEmptyArray(void){ return CProxySection_ArrayElement::ckCreateEmptyArray(); }
inline static CkArrayID ckCreateArray(CkArrayMessage *m,int ctor,const CkArrayOptions &opts){ return CProxySection_ArrayElement::ckCreateArray(m,ctor,opts); }
inline void ckInsertIdx(CkArrayMessage *m,int ctor,int onPe,const CkArrayIndex &idx){ CProxySection_ArrayElement::ckInsertIdx(m,ctor,onPe,idx); }
inline void ckBroadcast(CkArrayMessage *m, int ep, int opts=0) const{ CProxySection_ArrayElement::ckBroadcast(m,ep,opts); }
inline CkArrayID ckGetArrayID(void) const{ return CProxySection_ArrayElement::ckGetArrayID();}
inline CkArray *ckLocalBranch(void) const{ return CProxySection_ArrayElement::ckLocalBranch(); }
inline CkLocMgr *ckLocMgr(void) const{ return CProxySection_ArrayElement::ckLocMgr(); }
inline void doneInserting(void) { CProxySection_ArrayElement::doneInserting(); }
inline void setReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxySection_ArrayElement::setReductionClient(fn,param); }
inline void ckSetReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxySection_ArrayElement::ckSetReductionClient(fn,param); }
inline void ckSetReductionClient(CkCallback *cb) const
{ CProxySection_ArrayElement::ckSetReductionClient(cb); }
inline void ckSend(CkArrayMessage *m, int ep, int opts = 0)
 { CProxySection_ArrayElement::ckSend(m,ep,opts); }
inline CkSectionInfo &ckGetSectionInfo()
  { return CProxySection_ArrayElement::ckGetSectionInfo(); }
inline CkSectionID *ckGetSectionIDs()
  { return CProxySection_ArrayElement::ckGetSectionIDs(); }
inline CkSectionID &ckGetSectionID()
  { return CProxySection_ArrayElement::ckGetSectionID(); }
inline CkSectionID &ckGetSectionID(int i)
  { return CProxySection_ArrayElement::ckGetSectionID(i); }
inline CkArrayID ckGetArrayIDn(int i) const
{return CProxySection_ArrayElement::ckGetArrayIDn(i); } 
inline CkArrayIndexMax *ckGetArrayElements() const
  { return CProxySection_ArrayElement::ckGetArrayElements(); }
inline CkArrayIndexMax *ckGetArrayElements(int i) const
{return CProxySection_ArrayElement::ckGetArrayElements(i); }
inline int ckGetNumElements() const
  { return CProxySection_ArrayElement::ckGetNumElements(); } 
inline int ckGetNumElements(int i) const
{return CProxySection_ArrayElement::ckGetNumElements(i); } 
//Generalized array indexing:
    CProxyElement_LUBlk operator [] (const CkArrayIndex2D &idx) const
        {return CProxyElement_LUBlk(ckGetArrayID(), idx, CK_DELCTOR_CALL);}
    CProxyElement_LUBlk operator() (const CkArrayIndex2D &idx) const
        {return CProxyElement_LUBlk(ckGetArrayID(), idx, CK_DELCTOR_CALL);}
    CProxyElement_LUBlk operator () (int idx) const 
        {return CProxyElement_LUBlk(ckGetArrayID(), *(CkArrayIndex2D*)&ckGetArrayElements()[idx], CK_DELCTOR_CALL);}
    static CkSectionID ckNew(const CkArrayID &aid, CkArrayIndex2D *elems, int nElems) {
      return CkSectionID(aid, elems, nElems);
    } 
    static CkSectionID ckNew(const CkArrayID &aid, int l1, int u1, int s1, int l2, int u2, int s2) {
      CkVec<CkArrayIndex2D> al;
      for (int i=l1; i<=u1; i+=s1) 
        for (int j=l2; j<=u2; j+=s2) 
          al.push_back(CkArrayIndex2D(i, j));
      return CkSectionID(aid, al.getVec(), al.size());
    } 
    CProxySection_LUBlk(const CkArrayID &aid, CkArrayIndexMax *elems, int nElems, CK_DELCTOR_PARAM) 
        :CProxySection_ArrayElement(aid,elems,nElems,CK_DELCTOR_ARGS) {}
    CProxySection_LUBlk(const CkArrayID &aid, CkArrayIndexMax *elems, int nElems) 
        :CProxySection_ArrayElement(aid,elems,nElems) {}
    CProxySection_LUBlk(const CkSectionID &sid)       :CProxySection_ArrayElement(sid) {}
    CProxySection_LUBlk(int n, const CkArrayID *aid, CkArrayIndexMax const * const *elems, const int *nElems, CK_DELCTOR_PARAM) 
        :CProxySection_ArrayElement(n,aid,elems,nElems,CK_DELCTOR_ARGS) {}
    CProxySection_LUBlk(int n, const CkArrayID *aid, CkArrayIndexMax const * const *elems, const int *nElems) 
        :CProxySection_ArrayElement(n,aid,elems,nElems) {}
    static CkSectionID ckNew(const CkArrayID &aid, CkArrayIndexMax *elems, int nElems) {
      return CkSectionID(aid, elems, nElems);
    } 
/* DECLS: LUBlk(CkMigrateMessage* impl_msg);
 */

/* DECLS: LUBlk(void);
 */

/* DECLS: void prepareForPivotRedn(rednSetupMsg* impl_msg);
 */
    void prepareForPivotRedn(rednSetupMsg* impl_msg) ;

/* DECLS: void prepareForActivePanel(rednSetupMsg* impl_msg);
 */
    void prepareForActivePanel(rednSetupMsg* impl_msg) ;

/* DECLS: void prepareForPivotLR(rednSetupMsg* impl_msg);
 */
    void prepareForPivotLR(rednSetupMsg* impl_msg) ;

/* DECLS: void prepareForRowBeforeDiag(rednSetupMsg* impl_msg);
 */
    void prepareForRowBeforeDiag(rednSetupMsg* impl_msg) ;

/* DECLS: void prepareForRowAfterDiag(rednSetupMsg* impl_msg);
 */
    void prepareForRowAfterDiag(rednSetupMsg* impl_msg) ;

/* DECLS: void prepareForMulticastL(rednSetupMsg* impl_msg);
 */
    void prepareForMulticastL(rednSetupMsg* impl_msg) ;

/* DECLS: void multicastRedns(int dummy);
 */
    void multicastRedns(int dummy, const CkEntryOptions *impl_e_opts=NULL) ;

/* DECLS: void initVec(void);
 */
    void initVec(void) ;

/* DECLS: void startValidation(void);
 */
    void startValidation(void) ;

/* DECLS: void recvXvec(int size, const double *xvec);
 */
    void recvXvec(int size, const double *xvec, const CkEntryOptions *impl_e_opts=NULL) ;

/* DECLS: void sumBvec(int size, const double *partial_b);
 */
    void sumBvec(int size, const double *partial_b, const CkEntryOptions *impl_e_opts=NULL) ;

/* DECLS: void colMax(CkReductionMsg* impl_msg);
 */
    void colMax(CkReductionMsg* impl_msg) ;

/* DECLS: void sendPivotData(int rowIndex, int pivotRow, int size, const double *data, double b);
 */
    void sendPivotData(int rowIndex, int pivotRow, int size, const double *data, double b, const CkEntryOptions *impl_e_opts=NULL) ;

/* DECLS: void applyPivots(pivotSequencesMsg* impl_msg);
 */
    void applyPivots(pivotSequencesMsg* impl_msg) ;

/* DECLS: void acceptPivotData(pivotRowsMsg* impl_msg);
 */
    void acceptPivotData(pivotRowsMsg* impl_msg) ;

/* DECLS: void sendUSegment(UMsg* impl_msg);
 */
    void sendUSegment(UMsg* impl_msg) ;

/* DECLS: void performUpdate(int impl_noname_0);
 */
    void performUpdate(int impl_noname_0, const CkEntryOptions *impl_e_opts=NULL) ;

/* DECLS: void blockUsed(int impl_noname_1);
 */
    void blockUsed(int impl_noname_1, const CkEntryOptions *impl_e_opts=NULL) ;

/* DECLS: void getBlock(int pe);
 */
    void getBlock(int pe, const CkEntryOptions *impl_e_opts=NULL) ;

/* DECLS: void belowPivot(int targetCol);
 */
    void belowPivot(int targetCol, const CkEntryOptions *impl_e_opts=NULL) ;

/* DECLS: void factor(void);
 */
    void factor(void) ;

/* DECLS: void processLU(void);
 */
    void processLU(void) ;

/* DECLS: void beginForward(int size, const double *preVec);
 */
    void beginForward(int size, const double *preVec, const CkEntryOptions *impl_e_opts=NULL) ;

/* DECLS: void beginBackward(int size, const double *preVec);
 */
    void beginBackward(int size, const double *preVec, const CkEntryOptions *impl_e_opts=NULL) ;

/* DECLS: void recvSolveData(CkReductionMsg* impl_msg);
 */
    void recvSolveData(CkReductionMsg* impl_msg) ;

/* DECLS: void startup(const LUConfig &luCfg, const CProxy_LUMgr &_mgr, const CProxy_BlockScheduler &bs);
 */
    void startup(const LUConfig &luCfg, const CProxy_LUMgr &_mgr, const CProxy_BlockScheduler &bs, const CkEntryOptions *impl_e_opts=NULL) ;

/* DECLS: void forwardSolve(void);
 */
    void forwardSolve(void) ;

/* DECLS: void backwardSolve(void);
 */
    void backwardSolve(void) ;

/* DECLS: void recvL(blkMsg* impl_msg);
 */
    void recvL(blkMsg* impl_msg) ;

/* DECLS: void processTrailingUpdate(int step, const intptr_t &update_ptr);
 */

/* DECLS: void processComputeU(int ignoredParam);
 */
    void processComputeU(int ignoredParam, const CkEntryOptions *impl_e_opts=NULL) ;

/* DECLS: void flushLogs(void);
 */
    void flushLogs(void) ;

/* DECLS: void print(void);
 */
    void print(void) ;

};
PUPmarshall(CProxySection_LUBlk)
#define LUBlk_SDAG_CODE                                                        \
public:                                                                        \
  void belowPivot(int targetCol) {                                             \
    _slist_0(targetCol);                                                       \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _dummyEP, CkMyPe(), 0, NULL);        \
  }                                                                            \
                                                                               \
private:                                                                       \
  void belowPivot_end(int targetCol) {                                         \
  }                                                                            \
                                                                               \
  void _slist_0(int targetCol) {                                               \
    _when_0(targetCol);                                                        \
  }                                                                            \
  void _slist_0_end(int targetCol) {                                           \
    belowPivot_end(targetCol);                                                 \
  }                                                                            \
  int _when_0(int targetCol) {                                                 \
    CMsgBuffer *sendPivotData_buf;                                             \
    CkMarshallMsg *sendPivotData_msg;                                          \
                                                                               \
    sendPivotData_buf = __cDep->getMessage(0, internalStep*BLKSIZE + targetCol);\
                                                                               \
    if ((sendPivotData_buf != 0)) {                                            \
       sendPivotData_msg = (CkMarshallMsg *)sendPivotData_buf->msg;            \
       char *sendPivotData_impl_buf=((CkMarshallMsg *)sendPivotData_msg)->msgBuf;\
       PUP::fromMem sendPivotData_implP(sendPivotData_impl_buf);               \
       int rowIndex; sendPivotData_implP|rowIndex;                             \
       int pivotRow; sendPivotData_implP|pivotRow;                             \
       int size; sendPivotData_implP|size;                                     \
      int impl_off_data; sendPivotData_implP|impl_off_data;                    \
       double b; sendPivotData_implP|b;                                        \
       sendPivotData_impl_buf+=CK_ALIGN(sendPivotData_implP.size(),16);        \
    double *data=(double *)(sendPivotData_impl_buf+impl_off_data);             \
       __cDep->removeMessage(sendPivotData_buf);                               \
       delete sendPivotData_buf;                                               \
       _slist_1(targetCol, rowIndex, pivotRow, size, data, b);                 \
       delete sendPivotData_msg;                                               \
       return 1;                                                               \
    } else {                                                                   \
       CWhenTrigger *tr;                                                       \
       tr = new CWhenTrigger(0, 1, 1, 0);                                      \
       int impl_off=0;                                                         \
       {                                                                       \
         PUP::sizer implP;                                                     \
         implP|targetCol;                                                      \
         impl_off+=implP.size();                                               \
       }                                                                       \
       CkMarshallMsg *impl_msg;                                                \
       impl_msg = CkAllocateMarshallMsg(impl_off,NULL);                        \
       {                                                                       \
         PUP::toMem implP((void *)impl_msg->msgBuf);                           \
         implP|targetCol;                                                      \
       }                                                                       \
       tr->args[0] = (size_t) impl_msg;                                        \
       tr->entries[0] = 0;                                                     \
       tr->refnums[0] = internalStep*BLKSIZE + targetCol;                      \
       __cDep->Register(tr);                                                   \
       return 0;                                                               \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _when_0_end(int targetCol, int rowIndex, int pivotRow, int size, double *data, double b) {\
    _slist_0_end(targetCol);                                                   \
  }                                                                            \
                                                                               \
  void _slist_1(int targetCol, int rowIndex, int pivotRow, int size, double *data, double b) {\
    _atomic_0(targetCol, rowIndex, pivotRow, size, data, b);                   \
  }                                                                            \
  void _slist_1_end(int targetCol, int rowIndex, int pivotRow, int size, double *data, double b) {\
    _when_0_end(targetCol, rowIndex, pivotRow, size, data, b);                 \
  }                                                                            \
  void _atomic_0(int targetCol, int rowIndex, int pivotRow, int size, double *data, double b) {\
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_below_send_remote_pivot, CkMyPe(), 0, NULL); \
                                                                               \
    CkAssert(pivotRow / BLKSIZE == thisIndex.x);                               \
          CkEntryOptions opts;                                                 \
    thisProxy(thisIndex.y, thisIndex.y)                                        \
      .sendPivotData(internalStep*BLKSIZE + targetCol, pivotRow, BLKSIZE,      \
         &LU[pivotRow % BLKSIZE][0], bvec[pivotRow % BLKSIZE],                 \
                           &(mgr->setPrio(SEND_PIVOT_DATA, opts)));            \
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _atomic_1(targetCol, rowIndex, pivotRow, size, data, b);                   \
  }                                                                            \
                                                                               \
  void _atomic_1(int targetCol, int rowIndex, int pivotRow, int size, double *data, double b) {\
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_below_send_useg, CkMyPe(), 0, NULL); \
                                                                               \
    UMsg *anUmsg = new(BLKSIZE - targetCol, sizeof(int)*8) UMsg(BLKSIZE - targetCol, &LU[pivotRow % BLKSIZE][targetCol]);\
          mgr->setPrio(anUmsg, BELOW_SEND_USEG, internalStep*BLKSIZE + targetCol);\
          CkSetRefNum(anUmsg, internalStep*BLKSIZE + targetCol);               \
    pendingUmsg = (UMsg*)CkCopyMsg((void**)(&anUmsg));                         \
    activePanel.sendUSegment(anUmsg);                                          \
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _atomic_2(targetCol, rowIndex, pivotRow, size, data, b);                   \
  }                                                                            \
                                                                               \
  void _atomic_2(int targetCol, int rowIndex, int pivotRow, int size, double *data, double b) {\
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_below_recv_remote_pivot, CkMyPe(), 0, NULL); \
                                                                               \
    applySwap(pivotRow % BLKSIZE, 0, data, b);                                 \
    thisProxy(thisIndex.x, thisIndex.y).sendUSegment(pendingUmsg);             \
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _slist_1_end(targetCol, rowIndex, pivotRow, size, data, b);                \
  }                                                                            \
                                                                               \
public:                                                                        \
  void factor() {                                                              \
    _slist_2();                                                                \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _dummyEP, CkMyPe(), 0, NULL);        \
  }                                                                            \
                                                                               \
private:                                                                       \
  void factor_end() {                                                          \
  }                                                                            \
                                                                               \
  void _slist_2() {                                                            \
    _atomic_3();                                                               \
  }                                                                            \
  void _slist_2_end() {                                                        \
    factor_end();                                                              \
  }                                                                            \
  void _atomic_3() {                                                           \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_atomic_3, CkMyPe(), 0, NULL); \
     pivotBatchTag = 0;                                                        \
    _TRACE_END_EXECUTE();                                                      \
    _for_0();                                                                  \
  }                                                                            \
                                                                               \
  void _for_0() {                                                              \
    internalStep = 0;                                                          \
    if ( internalStep < min(thisIndex.x,  thisIndex.y)) {                      \
      _slist_3();                                                              \
    } else {                                                                   \
      _if_0();                                                                 \
    }                                                                          \
  }                                                                            \
  void _for_0_end() {                                                          \
 internalStep++;                                                               \
    if ( internalStep < min(thisIndex.x,  thisIndex.y)) {                      \
      _slist_3();                                                              \
    } else {                                                                   \
      _if_0();                                                                 \
    }                                                                          \
  }                                                                            \
  void _slist_3() {                                                            \
    _while_0();                                                                \
  }                                                                            \
  void _slist_3_end() {                                                        \
    _for_0_end();                                                              \
  }                                                                            \
  void _while_0() {                                                            \
    if (pivotBatchTag < (internalStep+1)*BLKSIZE) {                            \
      _slist_4();                                                              \
    } else {                                                                   \
      _when_3();                                                               \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _while_0_end() {                                                        \
    if (pivotBatchTag < (internalStep+1)*BLKSIZE) {                            \
      _slist_4();                                                              \
    } else {                                                                   \
      _when_3();                                                               \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _slist_4() {                                                            \
    _when_1();                                                                 \
  }                                                                            \
  void _slist_4_end() {                                                        \
    _while_0_end();                                                            \
  }                                                                            \
  int _when_1() {                                                              \
    CMsgBuffer *msg_buf;                                                       \
    pivotSequencesMsg *msg;                                                    \
                                                                               \
    msg_buf = __cDep->getMessage(1, pivotBatchTag);                            \
                                                                               \
    if ((msg_buf != 0)) {                                                      \
       msg = (pivotSequencesMsg *) msg_buf->msg;                               \
       __cDep->removeMessage(msg_buf);                                         \
       delete msg_buf;                                                         \
       _slist_5(msg);                                                          \
       CmiFree(UsrToEnv(msg));                                                 \
       return 1;                                                               \
    } else {                                                                   \
       CWhenTrigger *tr;                                                       \
       tr = new CWhenTrigger(1, 1, 1, 0);                                      \
       tr->args[0] = (size_t) CkAllocSysMsg();                                 \
       tr->entries[0] = 1;                                                     \
       tr->refnums[0] = pivotBatchTag;                                         \
       __cDep->Register(tr);                                                   \
       return 0;                                                               \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _when_1_end(pivotSequencesMsg * msg) {                                  \
    _slist_4_end();                                                            \
  }                                                                            \
                                                                               \
  void _slist_5(pivotSequencesMsg * msg) {                                     \
    _atomic_4(msg);                                                            \
  }                                                                            \
  void _slist_5_end(pivotSequencesMsg * msg) {                                 \
    _when_1_end(msg);                                                          \
  }                                                                            \
  void _atomic_4(pivotSequencesMsg * msg) {                                    \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_sendOutgoingPivots_trailingChare, CkMyPe(), 0, NULL); \
     sendPendingPivots(msg);                                                   \
    _TRACE_END_EXECUTE();                                                      \
    _while_1(msg);                                                             \
  }                                                                            \
                                                                               \
  void _while_1(pivotSequencesMsg * msg) {                                     \
    if (pendingIncomingPivots > 0) {                                           \
      _slist_6(msg);                                                           \
    } else {                                                                   \
      _atomic_6(msg);                                                          \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _while_1_end(pivotSequencesMsg * msg) {                                 \
    if (pendingIncomingPivots > 0) {                                           \
      _slist_6(msg);                                                           \
    } else {                                                                   \
      _atomic_6(msg);                                                          \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _slist_6(pivotSequencesMsg * msg) {                                     \
    _when_2(msg);                                                              \
  }                                                                            \
  void _slist_6_end(pivotSequencesMsg * msg) {                                 \
    _while_1_end(msg);                                                         \
  }                                                                            \
  int _when_2(pivotSequencesMsg * msg) {                                       \
    CMsgBuffer *aMsg_buf;                                                      \
    pivotRowsMsg *aMsg;                                                        \
                                                                               \
    aMsg_buf = __cDep->getMessage(2, pivotBatchTag);                           \
                                                                               \
    if ((aMsg_buf != 0)) {                                                     \
       aMsg = (pivotRowsMsg *) aMsg_buf->msg;                                  \
       __cDep->removeMessage(aMsg_buf);                                        \
       delete aMsg_buf;                                                        \
       _atomic_5(msg, aMsg);                                                   \
       CmiFree(UsrToEnv(aMsg));                                                \
       return 1;                                                               \
    } else {                                                                   \
       CWhenTrigger *tr;                                                       \
       tr = new CWhenTrigger(2, 2, 1, 0);                                      \
       tr->args[0] = (size_t) CkAllocSysMsg();                                 \
       tr->args[1] = (size_t) msg;                                             \
       tr->entries[0] = 2;                                                     \
       tr->refnums[0] = pivotBatchTag;                                         \
       __cDep->Register(tr);                                                   \
       return 0;                                                               \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _when_2_end(pivotSequencesMsg * msg, pivotRowsMsg * aMsg) {             \
    _slist_6_end(msg);                                                         \
  }                                                                            \
                                                                               \
  void _atomic_5(pivotSequencesMsg * msg, pivotRowsMsg * aMsg) {               \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_acceptIncomingPivots_trailingChare, CkMyPe(), 0, NULL); \
                                                                               \
                          for (int i = 0; i < aMsg->nRows; i++)                \
                          {                                                    \
                              CkAssert(thisIndex.x == aMsg->rowNum[i]/BLKSIZE);\
                              applySwap(aMsg->rowNum[i]%BLKSIZE, 0, &(aMsg->rows[i*BLKSIZE]), aMsg->rhs[i]);\
                              pendingIncomingPivots--;                         \
                              VERY_VERBOSE_PIVOT_AGGLOM("[%d,%d] received pivot row %d for batch %d. %d pending\n",\
                                  thisIndex.x, thisIndex.y, aMsg->rowNum[i], pivotBatchTag, pendingIncomingPivots);\
                          }                                                    \
                          delete aMsg;                                         \
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _when_2_end(msg, aMsg);                                                    \
  }                                                                            \
                                                                               \
  void _atomic_6(pivotSequencesMsg * msg) {                                    \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_atomic_6, CkMyPe(), 0, NULL); \
                                                                               \
                      pivotBatchTag += msg->numRowsProcessed;                  \
                      delete msg;                                              \
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _slist_5_end(msg);                                                         \
  }                                                                            \
                                                                               \
  int _when_3() {                                                              \
    CMsgBuffer *processTrailingUpdate_buf;                                     \
    CkMarshallMsg *processTrailingUpdate_msg;                                  \
                                                                               \
    processTrailingUpdate_buf = __cDep->getMessage(3, internalStep);           \
                                                                               \
    if ((processTrailingUpdate_buf != 0)) {                                    \
       processTrailingUpdate_msg = (CkMarshallMsg *)processTrailingUpdate_buf->msg;\
       char *processTrailingUpdate_impl_buf=((CkMarshallMsg *)processTrailingUpdate_msg)->msgBuf;\
       PUP::fromMem processTrailingUpdate_implP(processTrailingUpdate_impl_buf);\
       int step; processTrailingUpdate_implP|step;                             \
       intptr_t update_ptr; processTrailingUpdate_implP|update_ptr;            \
       processTrailingUpdate_impl_buf+=CK_ALIGN(processTrailingUpdate_implP.size(),16);\
       __cDep->removeMessage(processTrailingUpdate_buf);                       \
       delete processTrailingUpdate_buf;                                       \
       _atomic_7(step, update_ptr);                                            \
       delete processTrailingUpdate_msg;                                       \
       return 1;                                                               \
    } else {                                                                   \
       CWhenTrigger *tr;                                                       \
       tr = new CWhenTrigger(3, 1, 1, 0);                                      \
       tr->args[0] = (size_t) CkAllocSysMsg();                                 \
       tr->entries[0] = 3;                                                     \
       tr->refnums[0] = internalStep;                                          \
       __cDep->Register(tr);                                                   \
       return 0;                                                               \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _when_3_end(int step, intptr_t update_ptr) {                            \
    _slist_3_end();                                                            \
  }                                                                            \
                                                                               \
  void _atomic_7(int step, intptr_t update_ptr) {                              \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_trailing_update, CkMyPe(), 0, NULL); \
                                                                               \
        Update &update = *(Update *)update_ptr;                                \
        DEBUG_PRINT("doing trailing update");                                  \
        updateMatrix(update.L, update.U);                                      \
        thisProxy(thisIndex.x, internalStep).blockUsed(1);                     \
              scheduler.ckLocalBranch()->updateDone(update_ptr);               \
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _when_3_end(step, update_ptr);                                             \
  }                                                                            \
                                                                               \
  void _if_0() {                                                               \
    if (thisIndex.x == thisIndex.y) {                                          \
      _atomic_22();                                                            \
    } else {                                                                   \
      _else_0();                                                               \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _if_0_end() {                                                           \
      _if_2();                                                                 \
  }                                                                            \
                                                                               \
  void _else_0() {                                                             \
    double __begintime = CkVTimer();                                           \
     _TRACE_BG_USER_EVENT_BRACKET("_else_0", __begintime, CkVTimer(),&_bgParentLog); \
    _if_1();                                                                   \
  }                                                                            \
                                                                               \
  void _else_0_end() {                                                         \
      _if_2();                                                                 \
  }                                                                            \
                                                                               \
  void _if_1() {                                                               \
    if (thisIndex.x < thisIndex.y) {                                           \
      _slist_14();                                                             \
    } else {                                                                   \
      _else_1();                                                               \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _if_1_end() {                                                           \
      _else_0_end();                                                           \
  }                                                                            \
                                                                               \
  void _else_1() {                                                             \
    double __begintime = CkVTimer();                                           \
     _TRACE_BG_USER_EVENT_BRACKET("_else_1", __begintime, CkVTimer(),&_bgParentLog); \
    _slist_7();                                                                \
  }                                                                            \
                                                                               \
  void _else_1_end() {                                                         \
      _else_0_end();                                                           \
  }                                                                            \
                                                                               \
  void _slist_7() {                                                            \
    _atomic_8();                                                               \
  }                                                                            \
  void _slist_7_end() {                                                        \
    _else_1_end();                                                             \
  }                                                                            \
  void _atomic_8() {                                                           \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_atomic_8, CkMyPe(), 0, NULL); \
                                                                               \
                                                                               \
            pivotCandidate = findLocVal(0, 0);                                 \
            pendingUmsg = NULL;                                                \
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _for_1();                                                                  \
  }                                                                            \
                                                                               \
  void _for_1() {                                                              \
    activeCol = 0;                                                             \
    if ( activeCol < BLKSIZE) {                                                \
      _slist_8();                                                              \
    } else {                                                                   \
      _atomic_13();                                                            \
    }                                                                          \
  }                                                                            \
  void _for_1_end() {                                                          \
 activeCol++;                                                                  \
    if ( activeCol < BLKSIZE) {                                                \
      _slist_8();                                                              \
    } else {                                                                   \
      _atomic_13();                                                            \
    }                                                                          \
  }                                                                            \
  void _slist_8() {                                                            \
    _atomic_9();                                                               \
  }                                                                            \
  void _slist_8_end() {                                                        \
    _for_1_end();                                                              \
  }                                                                            \
  void _atomic_9() {                                                           \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_below_find_pivot, CkMyPe(), 0, NULL); \
                                                                               \
                                                                                         \
            mcastMgr->contribute(sizeof(locval), &pivotCandidate, LocValReducer, pivotCookie);\
      thisProxy(thisIndex.x, thisIndex.y).performUpdate(0);                    \
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _when_4();                                                                 \
  }                                                                            \
                                                                               \
  int _when_4() {                                                              \
    CMsgBuffer *performUpdate_buf;                                             \
    CkMarshallMsg *performUpdate_msg;                                          \
                                                                               \
    performUpdate_buf = __cDep->getMessage(4);                                 \
                                                                               \
    if ((performUpdate_buf != 0)) {                                            \
       performUpdate_msg = (CkMarshallMsg *)performUpdate_buf->msg;            \
       char *performUpdate_impl_buf=((CkMarshallMsg *)performUpdate_msg)->msgBuf;\
       PUP::fromMem performUpdate_implP(performUpdate_impl_buf);               \
       int dummy; performUpdate_implP|dummy;                                   \
       performUpdate_impl_buf+=CK_ALIGN(performUpdate_implP.size(),16);        \
       __cDep->removeMessage(performUpdate_buf);                               \
       delete performUpdate_buf;                                               \
       _atomic_10(dummy);                                                      \
       delete performUpdate_msg;                                               \
       return 1;                                                               \
    } else {                                                                   \
       CWhenTrigger *tr;                                                       \
       tr = new CWhenTrigger(4, 1, 0, 1);                                      \
       tr->args[0] = (size_t) CkAllocSysMsg();                                 \
       tr->anyEntries[0] = 4;                                                  \
       __cDep->Register(tr);                                                   \
       return 0;                                                               \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _when_4_end(int dummy) {                                                \
    _atomic_11();                                                              \
  }                                                                            \
                                                                               \
  void _atomic_10(int dummy) {                                                 \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_useg_delayed_update, CkMyPe(), 0, NULL); \
                                                                               \
                                                                               \
      if (pendingUmsg) {                                                       \
        updateLsubBlock(activeCol-1, pendingUmsg->data, 2);                    \
        dropRef(pendingUmsg);                                                  \
        pendingUmsg = NULL;                                                    \
      }                                                                        \
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _when_4_end(dummy);                                                        \
  }                                                                            \
                                                                               \
  void _atomic_11() {                                                          \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_atomic_11, CkMyPe(), 0, NULL); \
     thisProxy(thisIndex.x, thisIndex.y).belowPivot(activeCol);                \
    _TRACE_END_EXECUTE();                                                      \
    _when_5();                                                                 \
  }                                                                            \
                                                                               \
  int _when_5() {                                                              \
    CMsgBuffer *anUmsg_buf;                                                    \
    UMsg *anUmsg;                                                              \
                                                                               \
    anUmsg_buf = __cDep->getMessage(5);                                        \
                                                                               \
    if ((anUmsg_buf != 0)) {                                                   \
       anUmsg = (UMsg *) anUmsg_buf->msg;                                      \
       __cDep->removeMessage(anUmsg_buf);                                      \
       delete anUmsg_buf;                                                      \
       _atomic_12(anUmsg);                                                     \
       CmiFree(UsrToEnv(anUmsg));                                              \
       return 1;                                                               \
    } else {                                                                   \
       CWhenTrigger *tr;                                                       \
       tr = new CWhenTrigger(5, 1, 0, 1);                                      \
       tr->args[0] = (size_t) CkAllocSysMsg();                                 \
       tr->anyEntries[0] = 5;                                                  \
       __cDep->Register(tr);                                                   \
       return 0;                                                               \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _when_5_end(UMsg * anUmsg) {                                            \
    _slist_8_end();                                                            \
  }                                                                            \
                                                                               \
  void _atomic_12(UMsg * anUmsg) {                                             \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_below_recv_useg, CkMyPe(), 0, NULL); \
                                                                               \
                                                                                              \
            pivotCandidate = computeMultipliersAndFindColMax(activeCol, anUmsg->data);\
                                                                               \
            pendingUmsg = anUmsg;                                              \
            takeRef(pendingUmsg);                                              \
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _when_5_end(anUmsg);                                                       \
  }                                                                            \
                                                                               \
  void _atomic_13() {                                                          \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_below_send_L, CkMyPe(), 0, NULL); \
                                                                               \
          if (pendingUmsg) dropRef(pendingUmsg);                               \
          DEBUG_PRINT("done computing L");                                     \
    multicastRecvL();                                                          \
    factored = true;                                                           \
    scheduler.ckLocalBranch()->factorizationDone(thisIndex);                   \
          pivotBatchTag += BLKSIZE;                                            \
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _while_2();                                                                \
  }                                                                            \
                                                                               \
  void _while_2() {                                                            \
    if (blockPulled < numBlks-thisIndex.y-1) {                                 \
      _slist_9();                                                              \
    } else {                                                                   \
      _for_2();                                                                \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _while_2_end() {                                                        \
    if (blockPulled < numBlks-thisIndex.y-1) {                                 \
      _slist_9();                                                              \
    } else {                                                                   \
      _for_2();                                                                \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _slist_9() {                                                            \
    _when_6();                                                                 \
  }                                                                            \
  void _slist_9_end() {                                                        \
    _while_2_end();                                                            \
  }                                                                            \
  int _when_6() {                                                              \
    CMsgBuffer *blockUsed_buf;                                                 \
    CkMarshallMsg *blockUsed_msg;                                              \
                                                                               \
    blockUsed_buf = __cDep->getMessage(6);                                     \
                                                                               \
    if ((blockUsed_buf != 0)) {                                                \
       blockUsed_msg = (CkMarshallMsg *)blockUsed_buf->msg;                    \
       char *blockUsed_impl_buf=((CkMarshallMsg *)blockUsed_msg)->msgBuf;      \
       PUP::fromMem blockUsed_implP(blockUsed_impl_buf);                       \
       int count; blockUsed_implP|count;                                       \
       blockUsed_impl_buf+=CK_ALIGN(blockUsed_implP.size(),16);                \
       __cDep->removeMessage(blockUsed_buf);                                   \
       delete blockUsed_buf;                                                   \
       _atomic_14(count);                                                      \
       delete blockUsed_msg;                                                   \
       return 1;                                                               \
    } else {                                                                   \
       CWhenTrigger *tr;                                                       \
       tr = new CWhenTrigger(6, 1, 0, 1);                                      \
       tr->args[0] = (size_t) CkAllocSysMsg();                                 \
       tr->anyEntries[0] = 6;                                                  \
       __cDep->Register(tr);                                                   \
       return 0;                                                               \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _when_6_end(int count) {                                                \
    _slist_9_end();                                                            \
  }                                                                            \
                                                                               \
  void _atomic_14(int count) {                                                 \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_atomic_14, CkMyPe(), 0, NULL); \
     blockPulled += count;                                                     \
    _TRACE_END_EXECUTE();                                                      \
    _when_6_end(count);                                                        \
  }                                                                            \
                                                                               \
  void _for_2() {                                                              \
    internalStep++;                                                            \
    if (  internalStep <= thisIndex.x) {                                       \
      _slist_10();                                                             \
    } else {                                                                   \
      _slist_7_end();                                                          \
    }                                                                          \
  }                                                                            \
  void _for_2_end() {                                                          \
 internalStep++;                                                               \
    if (  internalStep <= thisIndex.x) {                                       \
      _slist_10();                                                             \
    } else {                                                                   \
      _slist_7_end();                                                          \
    }                                                                          \
  }                                                                            \
  void _slist_10() {                                                           \
    _while_3();                                                                \
  }                                                                            \
  void _slist_10_end() {                                                       \
    _for_2_end();                                                              \
  }                                                                            \
  void _while_3() {                                                            \
    if (pivotBatchTag < (internalStep+1)*BLKSIZE) {                            \
      _slist_11();                                                             \
    } else {                                                                   \
      _slist_10_end();                                                         \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _while_3_end() {                                                        \
    if (pivotBatchTag < (internalStep+1)*BLKSIZE) {                            \
      _slist_11();                                                             \
    } else {                                                                   \
      _slist_10_end();                                                         \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _slist_11() {                                                           \
    _when_7();                                                                 \
  }                                                                            \
  void _slist_11_end() {                                                       \
    _while_3_end();                                                            \
  }                                                                            \
  int _when_7() {                                                              \
    CMsgBuffer *msg_buf;                                                       \
    pivotSequencesMsg *msg;                                                    \
                                                                               \
    msg_buf = __cDep->getMessage(1, pivotBatchTag);                            \
                                                                               \
    if ((msg_buf != 0)) {                                                      \
       msg = (pivotSequencesMsg *) msg_buf->msg;                               \
       __cDep->removeMessage(msg_buf);                                         \
       delete msg_buf;                                                         \
       _slist_12(msg);                                                         \
       CmiFree(UsrToEnv(msg));                                                 \
       return 1;                                                               \
    } else {                                                                   \
       CWhenTrigger *tr;                                                       \
       tr = new CWhenTrigger(7, 1, 1, 0);                                      \
       tr->args[0] = (size_t) CkAllocSysMsg();                                 \
       tr->entries[0] = 1;                                                     \
       tr->refnums[0] = pivotBatchTag;                                         \
       __cDep->Register(tr);                                                   \
       return 0;                                                               \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _when_7_end(pivotSequencesMsg * msg) {                                  \
    _slist_11_end();                                                           \
  }                                                                            \
                                                                               \
  void _slist_12(pivotSequencesMsg * msg) {                                    \
    _atomic_15(msg);                                                           \
  }                                                                            \
  void _slist_12_end(pivotSequencesMsg * msg) {                                \
    _when_7_end(msg);                                                          \
  }                                                                            \
  void _atomic_15(pivotSequencesMsg * msg) {                                   \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_sendOutgoingPivots_leftSectionChare, CkMyPe(), 0, NULL); \
     sendPendingPivots(msg);                                                   \
    _TRACE_END_EXECUTE();                                                      \
    _while_4(msg);                                                             \
  }                                                                            \
                                                                               \
  void _while_4(pivotSequencesMsg * msg) {                                     \
    if (pendingIncomingPivots > 0) {                                           \
      _slist_13(msg);                                                          \
    } else {                                                                   \
      _atomic_17(msg);                                                         \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _while_4_end(pivotSequencesMsg * msg) {                                 \
    if (pendingIncomingPivots > 0) {                                           \
      _slist_13(msg);                                                          \
    } else {                                                                   \
      _atomic_17(msg);                                                         \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _slist_13(pivotSequencesMsg * msg) {                                    \
    _when_8(msg);                                                              \
  }                                                                            \
  void _slist_13_end(pivotSequencesMsg * msg) {                                \
    _while_4_end(msg);                                                         \
  }                                                                            \
  int _when_8(pivotSequencesMsg * msg) {                                       \
    CMsgBuffer *aMsg_buf;                                                      \
    pivotRowsMsg *aMsg;                                                        \
                                                                               \
    aMsg_buf = __cDep->getMessage(2, pivotBatchTag);                           \
                                                                               \
    if ((aMsg_buf != 0)) {                                                     \
       aMsg = (pivotRowsMsg *) aMsg_buf->msg;                                  \
       __cDep->removeMessage(aMsg_buf);                                        \
       delete aMsg_buf;                                                        \
       _atomic_16(msg, aMsg);                                                  \
       CmiFree(UsrToEnv(aMsg));                                                \
       return 1;                                                               \
    } else {                                                                   \
       CWhenTrigger *tr;                                                       \
       tr = new CWhenTrigger(8, 2, 1, 0);                                      \
       tr->args[0] = (size_t) CkAllocSysMsg();                                 \
       tr->args[1] = (size_t) msg;                                             \
       tr->entries[0] = 2;                                                     \
       tr->refnums[0] = pivotBatchTag;                                         \
       __cDep->Register(tr);                                                   \
       return 0;                                                               \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _when_8_end(pivotSequencesMsg * msg, pivotRowsMsg * aMsg) {             \
    _slist_13_end(msg);                                                        \
  }                                                                            \
                                                                               \
  void _atomic_16(pivotSequencesMsg * msg, pivotRowsMsg * aMsg) {              \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_acceptIncomingPivots_leftSectionChare, CkMyPe(), 0, NULL); \
                                                                               \
                          for (int i = 0; i < aMsg->nRows; i++)                \
                          {                                                    \
                              CkAssert(thisIndex.x == aMsg->rowNum[i]/BLKSIZE);\
                              applySwap(aMsg->rowNum[i]%BLKSIZE, 0, &(aMsg->rows[i*BLKSIZE]), aMsg->rhs[i]);\
                              pendingIncomingPivots--;                         \
                              VERY_VERBOSE_PIVOT_AGGLOM("[%d,%d] received pivot row %d for batch %d. %d pending\n",\
                                  thisIndex.x, thisIndex.y, aMsg->rowNum[i], pivotBatchTag, pendingIncomingPivots);\
                          }                                                    \
                          delete aMsg;                                         \
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _when_8_end(msg, aMsg);                                                    \
  }                                                                            \
                                                                               \
  void _atomic_17(pivotSequencesMsg * msg) {                                   \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_atomic_17, CkMyPe(), 0, NULL); \
                                                                               \
                      pivotBatchTag += msg->numRowsProcessed;                  \
                      delete msg;                                              \
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _slist_12_end(msg);                                                        \
  }                                                                            \
                                                                               \
  void _slist_14() {                                                           \
    _while_5();                                                                \
  }                                                                            \
  void _slist_14_end() {                                                       \
    _if_1_end();                                                               \
  }                                                                            \
  void _while_5() {                                                            \
    if (pivotBatchTag < (internalStep+1)*BLKSIZE) {                            \
      _slist_15();                                                             \
    } else {                                                                   \
      _when_11();                                                              \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _while_5_end() {                                                        \
    if (pivotBatchTag < (internalStep+1)*BLKSIZE) {                            \
      _slist_15();                                                             \
    } else {                                                                   \
      _when_11();                                                              \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _slist_15() {                                                           \
    _when_9();                                                                 \
  }                                                                            \
  void _slist_15_end() {                                                       \
    _while_5_end();                                                            \
  }                                                                            \
  int _when_9() {                                                              \
    CMsgBuffer *msg_buf;                                                       \
    pivotSequencesMsg *msg;                                                    \
                                                                               \
    msg_buf = __cDep->getMessage(1, pivotBatchTag);                            \
                                                                               \
    if ((msg_buf != 0)) {                                                      \
       msg = (pivotSequencesMsg *) msg_buf->msg;                               \
       __cDep->removeMessage(msg_buf);                                         \
       delete msg_buf;                                                         \
       _slist_16(msg);                                                         \
       CmiFree(UsrToEnv(msg));                                                 \
       return 1;                                                               \
    } else {                                                                   \
       CWhenTrigger *tr;                                                       \
       tr = new CWhenTrigger(9, 1, 1, 0);                                      \
       tr->args[0] = (size_t) CkAllocSysMsg();                                 \
       tr->entries[0] = 1;                                                     \
       tr->refnums[0] = pivotBatchTag;                                         \
       __cDep->Register(tr);                                                   \
       return 0;                                                               \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _when_9_end(pivotSequencesMsg * msg) {                                  \
    _slist_15_end();                                                           \
  }                                                                            \
                                                                               \
  void _slist_16(pivotSequencesMsg * msg) {                                    \
    _atomic_18(msg);                                                           \
  }                                                                            \
  void _slist_16_end(pivotSequencesMsg * msg) {                                \
    _when_9_end(msg);                                                          \
  }                                                                            \
  void _atomic_18(pivotSequencesMsg * msg) {                                   \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_sendOutgoingPivots_activeRowChare, CkMyPe(), 0, NULL); \
     sendPendingPivots(msg);                                                   \
    _TRACE_END_EXECUTE();                                                      \
    _while_6(msg);                                                             \
  }                                                                            \
                                                                               \
  void _while_6(pivotSequencesMsg * msg) {                                     \
    if (pendingIncomingPivots > 0) {                                           \
      _slist_17(msg);                                                          \
    } else {                                                                   \
      _atomic_20(msg);                                                         \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _while_6_end(pivotSequencesMsg * msg) {                                 \
    if (pendingIncomingPivots > 0) {                                           \
      _slist_17(msg);                                                          \
    } else {                                                                   \
      _atomic_20(msg);                                                         \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _slist_17(pivotSequencesMsg * msg) {                                    \
    _when_10(msg);                                                             \
  }                                                                            \
  void _slist_17_end(pivotSequencesMsg * msg) {                                \
    _while_6_end(msg);                                                         \
  }                                                                            \
  int _when_10(pivotSequencesMsg * msg) {                                      \
    CMsgBuffer *aMsg_buf;                                                      \
    pivotRowsMsg *aMsg;                                                        \
                                                                               \
    aMsg_buf = __cDep->getMessage(2, pivotBatchTag);                           \
                                                                               \
    if ((aMsg_buf != 0)) {                                                     \
       aMsg = (pivotRowsMsg *) aMsg_buf->msg;                                  \
       __cDep->removeMessage(aMsg_buf);                                        \
       delete aMsg_buf;                                                        \
       _atomic_19(msg, aMsg);                                                  \
       CmiFree(UsrToEnv(aMsg));                                                \
       return 1;                                                               \
    } else {                                                                   \
       CWhenTrigger *tr;                                                       \
       tr = new CWhenTrigger(10, 2, 1, 0);                                     \
       tr->args[0] = (size_t) CkAllocSysMsg();                                 \
       tr->args[1] = (size_t) msg;                                             \
       tr->entries[0] = 2;                                                     \
       tr->refnums[0] = pivotBatchTag;                                         \
       __cDep->Register(tr);                                                   \
       return 0;                                                               \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _when_10_end(pivotSequencesMsg * msg, pivotRowsMsg * aMsg) {            \
    _slist_17_end(msg);                                                        \
  }                                                                            \
                                                                               \
  void _atomic_19(pivotSequencesMsg * msg, pivotRowsMsg * aMsg) {              \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_acceptIncomingPivots_activeRowChare, CkMyPe(), 0, NULL); \
                                                                               \
                      for (int i = 0; i < aMsg->nRows; i++)                    \
                      {                                                        \
                          CkAssert(thisIndex.x == aMsg->rowNum[i]/BLKSIZE);    \
                          applySwap(aMsg->rowNum[i]%BLKSIZE, 0, &(aMsg->rows[i*BLKSIZE]), aMsg->rhs[i]);\
                          pendingIncomingPivots--;                             \
                          VERY_VERBOSE_PIVOT_AGGLOM("[%d,%d] received pivot row %d for batch %d. %d pending\n",\
                              thisIndex.x, thisIndex.y, aMsg->rowNum[i], pivotBatchTag, pendingIncomingPivots);\
                      }                                                        \
                      delete aMsg;                                             \
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _when_10_end(msg, aMsg);                                                   \
  }                                                                            \
                                                                               \
  void _atomic_20(pivotSequencesMsg * msg) {                                   \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_atomic_20, CkMyPe(), 0, NULL); \
                                                                               \
                  pivotBatchTag += msg->numRowsProcessed;                      \
                  delete msg;                                                  \
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _slist_16_end(msg);                                                        \
  }                                                                            \
                                                                               \
  int _when_11() {                                                             \
    CMsgBuffer *mL_buf;                                                        \
    blkMsg *mL;                                                                \
                                                                               \
    mL_buf = __cDep->getMessage(7, internalStep);                              \
                                                                               \
    if ((mL_buf != 0)) {                                                       \
       mL = (blkMsg *) mL_buf->msg;                                            \
       __cDep->removeMessage(mL_buf);                                          \
       delete mL_buf;                                                          \
       _atomic_21(mL);                                                         \
       CmiFree(UsrToEnv(mL));                                                  \
       return 1;                                                               \
    } else {                                                                   \
       CWhenTrigger *tr;                                                       \
       tr = new CWhenTrigger(11, 1, 1, 0);                                     \
       tr->args[0] = (size_t) CkAllocSysMsg();                                 \
       tr->entries[0] = 7;                                                     \
       tr->refnums[0] = internalStep;                                          \
       __cDep->Register(tr);                                                   \
       return 0;                                                               \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _when_11_end(blkMsg * mL) {                                             \
    _slist_14_end();                                                           \
  }                                                                            \
                                                                               \
  void _atomic_21(blkMsg * mL) {                                               \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_beforeL_schedule_computeU, CkMyPe(), 0, NULL); \
                                                                               \
          takeRef(mL);                                                         \
          L = mL;                                                              \
          CkEntryOptions opts;                                                 \
          thisProxy(thisIndex.x, thisIndex.y).processComputeU(0,               \
            &(mgr->setPrio(RECVL, opts, thisIndex.y)));                        \
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _when_11_end(mL);                                                          \
  }                                                                            \
                                                                               \
  void _atomic_22() {                                                          \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_atomic_22, CkMyPe(), 0, NULL); \
                                                                               \
        ckout << "--------------------------------------------------------------------"<<endl\
              <<"Block " << thisIndex.x << " queueing local LU at internalStep " << internalStep<<endl;\
        thisProxy(thisIndex.x, thisIndex.y).processLU();                       \
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _if_0_end();                                                               \
  }                                                                            \
                                                                               \
  void _if_2() {                                                               \
    if (thisIndex.x != thisIndex.y) {                                          \
      _slist_18();                                                             \
    } else {                                                                   \
      _if_2_end();                                                             \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _if_2_end() {                                                           \
      _slist_2_end();                                                          \
  }                                                                            \
                                                                               \
  void _slist_18() {                                                           \
    _atomic_23();                                                              \
  }                                                                            \
  void _slist_18_end() {                                                       \
    _if_2_end();                                                               \
  }                                                                            \
  void _atomic_23() {                                                          \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_offdiag_iteration_completed, CkMyPe(), 0, NULL); \
                                                                               \
    CkPrintf("(%d: [%d,%d]@%d) " "contributing" "\n", CkMyPe(), thisIndex.x, thisIndex.y, internalStep); \
          contribute(CkCallback(CkIndex_Main::startNextStep(), mainProxy));    \
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _slist_18_end();                                                           \
  }                                                                            \
                                                                               \
public:                                                                        \
  void processLU() {                                                           \
    _slist_19();                                                               \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _dummyEP, CkMyPe(), 0, NULL);        \
  }                                                                            \
                                                                               \
private:                                                                       \
  void processLU_end() {                                                       \
  }                                                                            \
                                                                               \
  void _slist_19() {                                                           \
    _atomic_24();                                                              \
  }                                                                            \
  void _slist_19_end() {                                                       \
    processLU_end();                                                           \
  }                                                                            \
  void _atomic_24() {                                                          \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_atomic_24, CkMyPe(), 0, NULL); \
                                                                               \
        if (STOP_AFTER == thisIndex.x) {                                       \
            flushLogs();                                                       \
            CkAbort("Aborting factorization in progress");                     \
        }                                                                      \
        CkAssert(pivotBatchTag == thisIndex.x*BLKSIZE);                        \
        pivotRecords.clear();                                                  \
        numRowsSinceLastPivotSend = 0;                                         \
                                                                               \
        pivotCandidate = findLocVal(0, 0);                                     \
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _for_3();                                                                  \
  }                                                                            \
                                                                               \
  void _for_3() {                                                              \
    activeCol = 0;                                                             \
    if ( activeCol < BLKSIZE) {                                                \
      _slist_20();                                                             \
    } else {                                                                   \
      _atomic_33();                                                            \
    }                                                                          \
  }                                                                            \
  void _for_3_end() {                                                          \
 ++activeCol;                                                                  \
    if ( activeCol < BLKSIZE) {                                                \
      _slist_20();                                                             \
    } else {                                                                   \
      _atomic_33();                                                            \
    }                                                                          \
  }                                                                            \
  void _slist_20() {                                                           \
    _atomic_25();                                                              \
  }                                                                            \
  void _slist_20_end() {                                                       \
    _for_3_end();                                                              \
  }                                                                            \
  void _atomic_25() {                                                          \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_diag_find_colmax, CkMyPe(), 0, NULL); \
                                                                               \
          VERBOSE_PROGRESS(" ..col%d ", thisIndex.x*BLKSIZE + activeCol);      \
                                                                                   \
          mcastMgr->contribute(sizeof(locval), &pivotCandidate, LocValReducer, pivotCookie);\
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _when_12();                                                                \
  }                                                                            \
                                                                               \
  int _when_12() {                                                             \
    CMsgBuffer *m_buf;                                                         \
    CkReductionMsg *m;                                                         \
                                                                               \
    m_buf = __cDep->getMessage(8);                                             \
                                                                               \
    if ((m_buf != 0)) {                                                        \
       m = (CkReductionMsg *) m_buf->msg;                                      \
       __cDep->removeMessage(m_buf);                                           \
       delete m_buf;                                                           \
       _slist_21(m);                                                           \
       CmiFree(UsrToEnv(m));                                                   \
       return 1;                                                               \
    } else {                                                                   \
       CWhenTrigger *tr;                                                       \
       tr = new CWhenTrigger(12, 1, 0, 1);                                     \
       tr->args[0] = (size_t) CkAllocSysMsg();                                 \
       tr->anyEntries[0] = 8;                                                  \
       __cDep->Register(tr);                                                   \
       return 0;                                                               \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _when_12_end(CkReductionMsg * m) {                                      \
    _atomic_31();                                                              \
  }                                                                            \
                                                                               \
  void _slist_21(CkReductionMsg * m) {                                         \
    _atomic_26(m);                                                             \
  }                                                                            \
  void _slist_21_end(CkReductionMsg * m) {                                     \
    _when_12_end(m);                                                           \
  }                                                                            \
  void _atomic_26(CkReductionMsg * m) {                                        \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_diag_found_colmax, CkMyPe(), 0, NULL); \
                                                                               \
      pivotCandidate = *(locval *)(m->getData());                              \
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _if_3(m);                                                                  \
  }                                                                            \
                                                                               \
  void _if_3(CkReductionMsg * m) {                                             \
    if (pivotCandidate.loc / BLKSIZE == thisIndex.x) {                         \
      _slist_23(m);                                                            \
    } else {                                                                   \
      _else_2(m);                                                              \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _if_3_end(CkReductionMsg * m) {                                         \
      _slist_21_end(m);                                                        \
  }                                                                            \
                                                                               \
  void _else_2(CkReductionMsg * m) {                                           \
    double __begintime = CkVTimer();                                           \
     _TRACE_BG_USER_EVENT_BRACKET("_else_2", __begintime, CkVTimer(),&_bgParentLog); \
    _slist_22(m);                                                              \
  }                                                                            \
                                                                               \
  void _else_2_end(CkReductionMsg * m) {                                       \
      _slist_21_end(m);                                                        \
  }                                                                            \
                                                                               \
  void _slist_22(CkReductionMsg * m) {                                         \
    _atomic_27(m);                                                             \
  }                                                                            \
  void _slist_22_end(CkReductionMsg * m) {                                     \
    _else_2_end(m);                                                            \
  }                                                                            \
  void _atomic_27(CkReductionMsg * m) {                                        \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_diag_send_remote_pivot, CkMyPe(), 0, NULL); \
                                                                               \
                                                                               \
        CkEntryOptions opts;                                                   \
        thisProxy(pivotCandidate.loc / BLKSIZE, thisIndex.y)                   \
    .sendPivotData(internalStep*BLKSIZE + activeCol, pivotCandidate.loc, BLKSIZE,\
             &LU[(activeCol + BLKSIZE * thisIndex.y) % BLKSIZE][0],            \
             bvec[(activeCol + BLKSIZE * thisIndex.y) % BLKSIZE],              \
                               &(mgr->setPrio(DIAG_SEND_PIVOT, opts)));        \
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _when_13(m);                                                               \
  }                                                                            \
                                                                               \
  int _when_13(CkReductionMsg * m) {                                           \
    CMsgBuffer *sendPivotData_buf;                                             \
    CkMarshallMsg *sendPivotData_msg;                                          \
                                                                               \
    sendPivotData_buf = __cDep->getMessage(0, internalStep*BLKSIZE + activeCol);\
                                                                               \
    if ((sendPivotData_buf != 0)) {                                            \
       sendPivotData_msg = (CkMarshallMsg *)sendPivotData_buf->msg;            \
       char *sendPivotData_impl_buf=((CkMarshallMsg *)sendPivotData_msg)->msgBuf;\
       PUP::fromMem sendPivotData_implP(sendPivotData_impl_buf);               \
       int rowIndex; sendPivotData_implP|rowIndex;                             \
       int pivotRow; sendPivotData_implP|pivotRow;                             \
       int size; sendPivotData_implP|size;                                     \
      int impl_off_data; sendPivotData_implP|impl_off_data;                    \
       double b; sendPivotData_implP|b;                                        \
       sendPivotData_impl_buf+=CK_ALIGN(sendPivotData_implP.size(),16);        \
    double *data=(double *)(sendPivotData_impl_buf+impl_off_data);             \
       __cDep->removeMessage(sendPivotData_buf);                               \
       delete sendPivotData_buf;                                               \
       _atomic_28(m, rowIndex, pivotRow, size, data, b);                       \
       delete sendPivotData_msg;                                               \
       return 1;                                                               \
    } else {                                                                   \
       CWhenTrigger *tr;                                                       \
       tr = new CWhenTrigger(13, 2, 1, 0);                                     \
       tr->args[0] = (size_t) CkAllocSysMsg();                                 \
       tr->args[1] = (size_t) m;                                               \
       tr->entries[0] = 0;                                                     \
       tr->refnums[0] = internalStep*BLKSIZE + activeCol;                      \
       __cDep->Register(tr);                                                   \
       return 0;                                                               \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _when_13_end(CkReductionMsg * m, int rowIndex, int pivotRow, int size, double *data, double b) {\
    _slist_22_end(m);                                                          \
  }                                                                            \
                                                                               \
  void _atomic_28(CkReductionMsg * m, int rowIndex, int pivotRow, int size, double *data, double b) {\
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_diag_receive_remote_pivot, CkMyPe(), 0, NULL); \
                                                                               \
        applySwap(activeCol, 0, data, b);                                      \
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _when_13_end(m, rowIndex, pivotRow, size, data, b);                        \
  }                                                                            \
                                                                               \
  void _slist_23(CkReductionMsg * m) {                                         \
    _atomic_29(m);                                                             \
  }                                                                            \
  void _slist_23_end(CkReductionMsg * m) {                                     \
    _if_3_end(m);                                                              \
  }                                                                            \
  void _atomic_29(CkReductionMsg * m) {                                        \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_diag_send_useg, CkMyPe(), 0, NULL); \
                                                                               \
        UMsg *anUmsg = new(BLKSIZE - activeCol, sizeof(int)*8) UMsg(BLKSIZE - activeCol, &LU[pivotCandidate.loc%BLKSIZE][activeCol]);\
              mgr->setPrio(anUmsg, DIAG_SEND_USEG);                            \
        activePanel.sendUSegment(anUmsg);                                      \
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _atomic_30(m);                                                             \
  }                                                                            \
                                                                               \
  void _atomic_30(CkReductionMsg * m) {                                        \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_diag_local_pivot, CkMyPe(), 0, NULL); \
     swapLocal(activeCol, pivotCandidate.loc % BLKSIZE);                       \
    _TRACE_END_EXECUTE();                                                      \
    _slist_23_end(m);                                                          \
  }                                                                            \
                                                                               \
  void _atomic_31() {                                                          \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_diag_agglomerate_pivots, CkMyPe(), 0, NULL); \
                                                                               \
                                                                               \
            recordPivot(thisIndex.y*BLKSIZE + activeCol, pivotCandidate.loc);  \
                                                                               \
            if ( shouldSendPivots() || activeCol == BLKSIZE-1)                 \
                announceAgglomeratedPivots();                                  \
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _atomic_32();                                                              \
  }                                                                            \
                                                                               \
  void _atomic_32() {                                                          \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_diag_update, CkMyPe(), 0, NULL); \
                                                                               \
                                                                                                      \
            if (fabs(LU[activeCol][activeCol]) <= 100 * std::numeric_limits<double>::epsilon() )\
                CkAbort("Diagonal element very small despite pivoting. Is the matrix singular??");\
                                                                               \
            pivotCandidate = computeMultipliersAndFindColMax(activeCol, &LU[activeCol][activeCol], activeCol+1);\
                                                                               \
            updateLsubBlock(activeCol, &LU[activeCol][activeCol], 2, activeCol+1);\
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _slist_20_end();                                                           \
  }                                                                            \
                                                                               \
  void _atomic_33() {                                                          \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_diag_multicast_L, CkMyPe(), 0, NULL); \
                                                                               \
                                                                               \
        if (thisIndex.x < numBlks-1 && thisIndex.y < numBlks-1) {              \
          DEBUG_PRINT("is top,left block this step, multicast L");             \
                                                                                    \
          multicastRecvL();                                                    \
        }                                                                      \
                                                                                                   \
  CkPrintf("(%d: [%d,%d]@%d) " "contributing" "\n", CkMyPe(), thisIndex.x, thisIndex.y, internalStep);                                                 \
        contribute(CkCallback(CkIndex_Main::startNextStep(), mainProxy));      \
        VERBOSE_PROGRESS("\n");                                                \
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _slist_19_end();                                                           \
  }                                                                            \
                                                                               \
public:                                                                        \
  void startup(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs) {  \
    _slist_24(luCfg, _mgr, bs);                                                \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _dummyEP, CkMyPe(), 0, NULL);        \
  }                                                                            \
                                                                               \
private:                                                                       \
  void startup_end(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs) {\
  }                                                                            \
                                                                               \
  void _slist_24(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs) {\
    _atomic_34(luCfg, _mgr, bs);                                               \
  }                                                                            \
  void _slist_24_end(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs) {\
    startup_end(luCfg, _mgr, bs);                                              \
  }                                                                            \
  void _atomic_34(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs) {\
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_atomic_34, CkMyPe(), 0, NULL); \
                                                                               \
    init(luCfg, _mgr, bs);                                                     \
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _when_14(luCfg, _mgr, bs);                                                 \
  }                                                                            \
                                                                               \
  int _when_14(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs) {  \
    CMsgBuffer *multicastRedns_buf;                                            \
    CkMarshallMsg *multicastRedns_msg;                                         \
                                                                               \
    multicastRedns_buf = __cDep->getMessage(9);                                \
                                                                               \
    if ((multicastRedns_buf != 0)) {                                           \
       multicastRedns_msg = (CkMarshallMsg *)multicastRedns_buf->msg;          \
       char *multicastRedns_impl_buf=((CkMarshallMsg *)multicastRedns_msg)->msgBuf;\
       PUP::fromMem multicastRedns_implP(multicastRedns_impl_buf);             \
       int dummy; multicastRedns_implP|dummy;                                  \
       multicastRedns_impl_buf+=CK_ALIGN(multicastRedns_implP.size(),16);      \
       __cDep->removeMessage(multicastRedns_buf);                              \
       delete multicastRedns_buf;                                              \
       _slist_25(luCfg, _mgr, bs, dummy);                                      \
       delete multicastRedns_msg;                                              \
       return 1;                                                               \
    } else {                                                                   \
       CWhenTrigger *tr;                                                       \
       tr = new CWhenTrigger(14, 3, 0, 1);                                     \
       int impl_off=0;                                                         \
       {                                                                       \
         PUP::sizer implP;                                                     \
         implP|luCfg;                                                          \
         implP|_mgr;                                                           \
         implP|bs;                                                             \
         impl_off+=implP.size();                                               \
       }                                                                       \
       CkMarshallMsg *impl_msg;                                                \
       impl_msg = CkAllocateMarshallMsg(impl_off,NULL);                        \
       {                                                                       \
         PUP::toMem implP((void *)impl_msg->msgBuf);                           \
         implP|luCfg;                                                          \
         implP|_mgr;                                                           \
         implP|bs;                                                             \
       }                                                                       \
       tr->args[0] = (size_t) impl_msg;                                        \
       tr->anyEntries[0] = 9;                                                  \
       __cDep->Register(tr);                                                   \
       return 0;                                                               \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _when_14_end(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy) {\
    _slist_24_end(luCfg, _mgr, bs);                                            \
  }                                                                            \
                                                                               \
  void _slist_25(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy) {\
    _if_4(luCfg, _mgr, bs, dummy);                                             \
  }                                                                            \
  void _slist_25_end(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy) {\
    _when_14_end(luCfg, _mgr, bs, dummy);                                      \
  }                                                                            \
  void _if_4(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy) {\
    if (thisIndex.x >= thisIndex.y) {                                          \
      _slist_26(luCfg, _mgr, bs, dummy);                                       \
    } else {                                                                   \
      _if_4_end(luCfg, _mgr, bs, dummy);                                       \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _if_4_end(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy) {\
      _if_5(luCfg, _mgr, bs, dummy);                                           \
  }                                                                            \
                                                                               \
  void _slist_26(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy) {\
    _when_15(luCfg, _mgr, bs, dummy);                                          \
  }                                                                            \
  void _slist_26_end(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy) {\
    _if_4_end(luCfg, _mgr, bs, dummy);                                         \
  }                                                                            \
  int _when_15(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy) {\
    CMsgBuffer *msg_buf;                                                       \
    rednSetupMsg *msg;                                                         \
                                                                               \
    msg_buf = __cDep->getMessage(10);                                          \
                                                                               \
    if ((msg_buf != 0)) {                                                      \
       msg = (rednSetupMsg *) msg_buf->msg;                                    \
       __cDep->removeMessage(msg_buf);                                         \
       delete msg_buf;                                                         \
       _atomic_35(luCfg, _mgr, bs, dummy, msg);                                \
       CmiFree(UsrToEnv(msg));                                                 \
       return 1;                                                               \
    } else {                                                                   \
       CWhenTrigger *tr;                                                       \
       tr = new CWhenTrigger(15, 4, 0, 1);                                     \
       int impl_off=0;                                                         \
       {                                                                       \
         PUP::sizer implP;                                                     \
         implP|luCfg;                                                          \
         implP|_mgr;                                                           \
         implP|bs;                                                             \
         implP|dummy;                                                          \
         impl_off+=implP.size();                                               \
       }                                                                       \
       CkMarshallMsg *impl_msg;                                                \
       impl_msg = CkAllocateMarshallMsg(impl_off,NULL);                        \
       {                                                                       \
         PUP::toMem implP((void *)impl_msg->msgBuf);                           \
         implP|luCfg;                                                          \
         implP|_mgr;                                                           \
         implP|bs;                                                             \
         implP|dummy;                                                          \
       }                                                                       \
       tr->args[0] = (size_t) impl_msg;                                        \
       tr->anyEntries[0] = 10;                                                 \
       __cDep->Register(tr);                                                   \
       return 0;                                                               \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _when_15_end(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy, rednSetupMsg * msg) {\
    _slist_26_end(luCfg, _mgr, bs, dummy);                                     \
  }                                                                            \
                                                                               \
  void _atomic_35(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy, rednSetupMsg * msg) {\
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_atomic_35, CkMyPe(), 0, NULL); \
                                                                               \
            mcastMgr = CProxy_CkMulticastMgr(msg->rednMgrGID).ckLocalBranch(); \
            CkGetSectionInfo(pivotCookie, msg);                                \
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _when_15_end(luCfg, _mgr, bs, dummy, msg);                                 \
  }                                                                            \
                                                                               \
  void _if_5(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy) {\
    if (thisIndex.x > thisIndex.y) {                                           \
      _slist_28(luCfg, _mgr, bs, dummy);                                       \
    } else {                                                                   \
      _else_3(luCfg, _mgr, bs, dummy);                                         \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _if_5_end(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy) {\
      _for_4(luCfg, _mgr, bs, dummy);                                          \
  }                                                                            \
                                                                               \
  void _else_3(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy) {\
    double __begintime = CkVTimer();                                           \
     _TRACE_BG_USER_EVENT_BRACKET("_else_3", __begintime, CkVTimer(),&_bgParentLog); \
    _if_6(luCfg, _mgr, bs, dummy);                                             \
  }                                                                            \
                                                                               \
  void _else_3_end(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy) {\
      _for_4(luCfg, _mgr, bs, dummy);                                          \
  }                                                                            \
                                                                               \
  void _if_6(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy) {\
    if (thisIndex.x < thisIndex.y) {                                           \
      _slist_27(luCfg, _mgr, bs, dummy);                                       \
    } else {                                                                   \
      _if_6_end(luCfg, _mgr, bs, dummy);                                       \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _if_6_end(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy) {\
      _else_3_end(luCfg, _mgr, bs, dummy);                                     \
  }                                                                            \
                                                                               \
  void _slist_27(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy) {\
    _when_16(luCfg, _mgr, bs, dummy);                                          \
  }                                                                            \
  void _slist_27_end(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy) {\
    _if_6_end(luCfg, _mgr, bs, dummy);                                         \
  }                                                                            \
  int _when_16(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy) {\
    CMsgBuffer *msg_buf;                                                       \
    rednSetupMsg *msg;                                                         \
                                                                               \
    msg_buf = __cDep->getMessage(11);                                          \
                                                                               \
    if ((msg_buf != 0)) {                                                      \
       msg = (rednSetupMsg *) msg_buf->msg;                                    \
       __cDep->removeMessage(msg_buf);                                         \
       delete msg_buf;                                                         \
       _atomic_36(luCfg, _mgr, bs, dummy, msg);                                \
       CmiFree(UsrToEnv(msg));                                                 \
       return 1;                                                               \
    } else {                                                                   \
       CWhenTrigger *tr;                                                       \
       tr = new CWhenTrigger(16, 4, 0, 1);                                     \
       int impl_off=0;                                                         \
       {                                                                       \
         PUP::sizer implP;                                                     \
         implP|luCfg;                                                          \
         implP|_mgr;                                                           \
         implP|bs;                                                             \
         implP|dummy;                                                          \
         impl_off+=implP.size();                                               \
       }                                                                       \
       CkMarshallMsg *impl_msg;                                                \
       impl_msg = CkAllocateMarshallMsg(impl_off,NULL);                        \
       {                                                                       \
         PUP::toMem implP((void *)impl_msg->msgBuf);                           \
         implP|luCfg;                                                          \
         implP|_mgr;                                                           \
         implP|bs;                                                             \
         implP|dummy;                                                          \
       }                                                                       \
       tr->args[0] = (size_t) impl_msg;                                        \
       tr->anyEntries[0] = 11;                                                 \
       __cDep->Register(tr);                                                   \
       return 0;                                                               \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _when_16_end(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy, rednSetupMsg * msg) {\
    _slist_27_end(luCfg, _mgr, bs, dummy);                                     \
  }                                                                            \
                                                                               \
  void _atomic_36(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy, rednSetupMsg * msg) {\
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_atomic_36, CkMyPe(), 0, NULL); \
                                                                               \
            mcastMgr = CProxy_CkMulticastMgr(msg->rednMgrGID).ckLocalBranch(); \
            CkGetSectionInfo(rowAfterCookie, msg);                             \
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _when_16_end(luCfg, _mgr, bs, dummy, msg);                                 \
  }                                                                            \
                                                                               \
  void _slist_28(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy) {\
    _when_17(luCfg, _mgr, bs, dummy);                                          \
  }                                                                            \
  void _slist_28_end(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy) {\
    _if_5_end(luCfg, _mgr, bs, dummy);                                         \
  }                                                                            \
  int _when_17(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy) {\
    CMsgBuffer *msg_buf;                                                       \
    rednSetupMsg *msg;                                                         \
                                                                               \
    msg_buf = __cDep->getMessage(12);                                          \
                                                                               \
    if ((msg_buf != 0)) {                                                      \
       msg = (rednSetupMsg *) msg_buf->msg;                                    \
       __cDep->removeMessage(msg_buf);                                         \
       delete msg_buf;                                                         \
       _atomic_37(luCfg, _mgr, bs, dummy, msg);                                \
       CmiFree(UsrToEnv(msg));                                                 \
       return 1;                                                               \
    } else {                                                                   \
       CWhenTrigger *tr;                                                       \
       tr = new CWhenTrigger(17, 4, 0, 1);                                     \
       int impl_off=0;                                                         \
       {                                                                       \
         PUP::sizer implP;                                                     \
         implP|luCfg;                                                          \
         implP|_mgr;                                                           \
         implP|bs;                                                             \
         implP|dummy;                                                          \
         impl_off+=implP.size();                                               \
       }                                                                       \
       CkMarshallMsg *impl_msg;                                                \
       impl_msg = CkAllocateMarshallMsg(impl_off,NULL);                        \
       {                                                                       \
         PUP::toMem implP((void *)impl_msg->msgBuf);                           \
         implP|luCfg;                                                          \
         implP|_mgr;                                                           \
         implP|bs;                                                             \
         implP|dummy;                                                          \
       }                                                                       \
       tr->args[0] = (size_t) impl_msg;                                        \
       tr->anyEntries[0] = 12;                                                 \
       __cDep->Register(tr);                                                   \
       return 0;                                                               \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _when_17_end(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy, rednSetupMsg * msg) {\
    _slist_28_end(luCfg, _mgr, bs, dummy);                                     \
  }                                                                            \
                                                                               \
  void _atomic_37(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy, rednSetupMsg * msg) {\
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_atomic_37, CkMyPe(), 0, NULL); \
                                                                               \
            mcastMgr = CProxy_CkMulticastMgr(msg->rednMgrGID).ckLocalBranch(); \
            CkGetSectionInfo(rowBeforeCookie, msg);                            \
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _when_17_end(luCfg, _mgr, bs, dummy, msg);                                 \
  }                                                                            \
                                                                               \
  void _for_4(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy) {\
    ind = 0;                                                                   \
    if ( ind < thisIndex.x-1) {                                                \
      _slist_29(luCfg, _mgr, bs, dummy);                                       \
    } else {                                                                   \
      _for_5(luCfg, _mgr, bs, dummy);                                          \
    }                                                                          \
  }                                                                            \
  void _for_4_end(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy) {\
 ind++;                                                                        \
    if ( ind < thisIndex.x-1) {                                                \
      _slist_29(luCfg, _mgr, bs, dummy);                                       \
    } else {                                                                   \
      _for_5(luCfg, _mgr, bs, dummy);                                          \
    }                                                                          \
  }                                                                            \
  void _slist_29(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy) {\
    _when_18(luCfg, _mgr, bs, dummy);                                          \
  }                                                                            \
  void _slist_29_end(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy) {\
    _for_4_end(luCfg, _mgr, bs, dummy);                                        \
  }                                                                            \
  int _when_18(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy) {\
    CMsgBuffer *msg_buf;                                                       \
    rednSetupMsg *msg;                                                         \
                                                                               \
    msg_buf = __cDep->getMessage(13);                                          \
                                                                               \
    if ((msg_buf != 0)) {                                                      \
       msg = (rednSetupMsg *) msg_buf->msg;                                    \
       __cDep->removeMessage(msg_buf);                                         \
       delete msg_buf;                                                         \
       _atomic_38(luCfg, _mgr, bs, dummy, msg);                                \
       CmiFree(UsrToEnv(msg));                                                 \
       return 1;                                                               \
    } else {                                                                   \
       CWhenTrigger *tr;                                                       \
       tr = new CWhenTrigger(18, 4, 0, 1);                                     \
       int impl_off=0;                                                         \
       {                                                                       \
         PUP::sizer implP;                                                     \
         implP|luCfg;                                                          \
         implP|_mgr;                                                           \
         implP|bs;                                                             \
         implP|dummy;                                                          \
         impl_off+=implP.size();                                               \
       }                                                                       \
       CkMarshallMsg *impl_msg;                                                \
       impl_msg = CkAllocateMarshallMsg(impl_off,NULL);                        \
       {                                                                       \
         PUP::toMem implP((void *)impl_msg->msgBuf);                           \
         implP|luCfg;                                                          \
         implP|_mgr;                                                           \
         implP|bs;                                                             \
         implP|dummy;                                                          \
       }                                                                       \
       tr->args[0] = (size_t) impl_msg;                                        \
       tr->anyEntries[0] = 13;                                                 \
       __cDep->Register(tr);                                                   \
       return 0;                                                               \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _when_18_end(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy, rednSetupMsg * msg) {\
    _slist_29_end(luCfg, _mgr, bs, dummy);                                     \
  }                                                                            \
                                                                               \
  void _atomic_38(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy, rednSetupMsg * msg) {\
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_atomic_38, CkMyPe(), 0, NULL); \
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _when_18_end(luCfg, _mgr, bs, dummy, msg);                                 \
  }                                                                            \
                                                                               \
  void _for_5(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy) {\
    ind = 0;                                                                   \
    if ( ind < min(thisIndex.x,  thisIndex.y)) {                               \
      _slist_30(luCfg, _mgr, bs, dummy);                                       \
    } else {                                                                   \
      _atomic_40(luCfg, _mgr, bs, dummy);                                      \
    }                                                                          \
  }                                                                            \
  void _for_5_end(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy) {\
 ind++;                                                                        \
    if ( ind < min(thisIndex.x,  thisIndex.y)) {                               \
      _slist_30(luCfg, _mgr, bs, dummy);                                       \
    } else {                                                                   \
      _atomic_40(luCfg, _mgr, bs, dummy);                                      \
    }                                                                          \
  }                                                                            \
  void _slist_30(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy) {\
    _when_19(luCfg, _mgr, bs, dummy);                                          \
  }                                                                            \
  void _slist_30_end(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy) {\
    _for_5_end(luCfg, _mgr, bs, dummy);                                        \
  }                                                                            \
  int _when_19(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy) {\
    CMsgBuffer *msg_buf;                                                       \
    rednSetupMsg *msg;                                                         \
                                                                               \
    msg_buf = __cDep->getMessage(14);                                          \
                                                                               \
    if ((msg_buf != 0)) {                                                      \
       msg = (rednSetupMsg *) msg_buf->msg;                                    \
       __cDep->removeMessage(msg_buf);                                         \
       delete msg_buf;                                                         \
       _atomic_39(luCfg, _mgr, bs, dummy, msg);                                \
       CmiFree(UsrToEnv(msg));                                                 \
       return 1;                                                               \
    } else {                                                                   \
       CWhenTrigger *tr;                                                       \
       tr = new CWhenTrigger(19, 4, 0, 1);                                     \
       int impl_off=0;                                                         \
       {                                                                       \
         PUP::sizer implP;                                                     \
         implP|luCfg;                                                          \
         implP|_mgr;                                                           \
         implP|bs;                                                             \
         implP|dummy;                                                          \
         impl_off+=implP.size();                                               \
       }                                                                       \
       CkMarshallMsg *impl_msg;                                                \
       impl_msg = CkAllocateMarshallMsg(impl_off,NULL);                        \
       {                                                                       \
         PUP::toMem implP((void *)impl_msg->msgBuf);                           \
         implP|luCfg;                                                          \
         implP|_mgr;                                                           \
         implP|bs;                                                             \
         implP|dummy;                                                          \
       }                                                                       \
       tr->args[0] = (size_t) impl_msg;                                        \
       tr->anyEntries[0] = 14;                                                 \
       __cDep->Register(tr);                                                   \
       return 0;                                                               \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _when_19_end(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy, rednSetupMsg * msg) {\
    _slist_30_end(luCfg, _mgr, bs, dummy);                                     \
  }                                                                            \
                                                                               \
  void _atomic_39(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy, rednSetupMsg * msg) {\
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_atomic_39, CkMyPe(), 0, NULL); \
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _when_19_end(luCfg, _mgr, bs, dummy, msg);                                 \
  }                                                                            \
                                                                               \
  void _atomic_40(LUConfig luCfg, CProxy_LUMgr _mgr, CProxy_BlockScheduler bs, int dummy) {\
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_atomic_40, CkMyPe(), 0, NULL); \
                                                                               \
          contribute(CkCallback(CkIndex_Main::finishInit(), mainProxy));       \
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _slist_25_end(luCfg, _mgr, bs, dummy);                                     \
  }                                                                            \
                                                                               \
public:                                                                        \
  void forwardSolve() {                                                        \
    _slist_31();                                                               \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _dummyEP, CkMyPe(), 0, NULL);        \
  }                                                                            \
                                                                               \
private:                                                                       \
  void forwardSolve_end() {                                                    \
  }                                                                            \
                                                                               \
  void _slist_31() {                                                           \
    _if_7();                                                                   \
  }                                                                            \
  void _slist_31_end() {                                                       \
    forwardSolve_end();                                                        \
  }                                                                            \
  void _if_7() {                                                               \
    if (thisIndex.x > 0) {                                                     \
      _slist_32();                                                             \
    } else {                                                                   \
      _if_7_end();                                                             \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _if_7_end() {                                                           \
      _atomic_42();                                                            \
  }                                                                            \
                                                                               \
  void _slist_32() {                                                           \
    _when_20();                                                                \
  }                                                                            \
  void _slist_32_end() {                                                       \
    _if_7_end();                                                               \
  }                                                                            \
  int _when_20() {                                                             \
    CMsgBuffer *m_buf;                                                         \
    CkReductionMsg *m;                                                         \
                                                                               \
    m_buf = __cDep->getMessage(15, thisIndex.x);                               \
                                                                               \
    if ((m_buf != 0)) {                                                        \
       m = (CkReductionMsg *) m_buf->msg;                                      \
       __cDep->removeMessage(m_buf);                                           \
       delete m_buf;                                                           \
       _atomic_41(m);                                                          \
       CmiFree(UsrToEnv(m));                                                   \
       return 1;                                                               \
    } else {                                                                   \
       CWhenTrigger *tr;                                                       \
       tr = new CWhenTrigger(20, 1, 1, 0);                                     \
       tr->args[0] = (size_t) CkAllocSysMsg();                                 \
       tr->entries[0] = 15;                                                    \
       tr->refnums[0] = thisIndex.x;                                           \
       __cDep->Register(tr);                                                   \
       return 0;                                                               \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _when_20_end(CkReductionMsg * m) {                                      \
    _slist_32_end();                                                           \
  }                                                                            \
                                                                               \
  void _atomic_41(CkReductionMsg * m) {                                        \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_atomic_41, CkMyPe(), 0, NULL); \
                                                                               \
            double *preVec = (double*) ( m->getData() );                       \
            for (int i = 0; i < BLKSIZE; i++)                                  \
              bvec[i] -= preVec[i];                                            \
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _when_20_end(m);                                                           \
  }                                                                            \
                                                                               \
  void _atomic_42() {                                                          \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_atomic_42, CkMyPe(), 0, NULL); \
                                                                               \
          localForward(bvec);                                                  \
          if (thisIndex.x == numBlks-1)                                        \
            thisProxy(thisIndex.x, thisIndex.y).backwardSolve();               \
          else {                                                               \
                                                                               \
            CProxySection_LUBlk col = CProxySection_LUBlk::ckNew(thisArrayID,  \
                                                    thisIndex.x+1, numBlks-1, 1,\
                                                    thisIndex.y, thisIndex.y, 1);\
            col.beginForward(BLKSIZE, bvec);                                   \
            thisProxy(thisIndex.x+1,thisIndex.y+1).forwardSolve();             \
          }                                                                    \
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _slist_31_end();                                                           \
  }                                                                            \
                                                                               \
public:                                                                        \
  void backwardSolve() {                                                       \
    _slist_33();                                                               \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _dummyEP, CkMyPe(), 0, NULL);        \
  }                                                                            \
                                                                               \
private:                                                                       \
  void backwardSolve_end() {                                                   \
  }                                                                            \
                                                                               \
  void _slist_33() {                                                           \
    _if_8();                                                                   \
  }                                                                            \
  void _slist_33_end() {                                                       \
    backwardSolve_end();                                                       \
  }                                                                            \
  void _if_8() {                                                               \
    if (thisIndex.x < numBlks-1) {                                             \
      _slist_34();                                                             \
    } else {                                                                   \
      _if_8_end();                                                             \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _if_8_end() {                                                           \
      _atomic_44();                                                            \
  }                                                                            \
                                                                               \
  void _slist_34() {                                                           \
    _when_21();                                                                \
  }                                                                            \
  void _slist_34_end() {                                                       \
    _if_8_end();                                                               \
  }                                                                            \
  int _when_21() {                                                             \
    CMsgBuffer *m_buf;                                                         \
    CkReductionMsg *m;                                                         \
                                                                               \
    m_buf = __cDep->getMessage(15, thisIndex.x);                               \
                                                                               \
    if ((m_buf != 0)) {                                                        \
       m = (CkReductionMsg *) m_buf->msg;                                      \
       __cDep->removeMessage(m_buf);                                           \
       delete m_buf;                                                           \
       _atomic_43(m);                                                          \
       CmiFree(UsrToEnv(m));                                                   \
       return 1;                                                               \
    } else {                                                                   \
       CWhenTrigger *tr;                                                       \
       tr = new CWhenTrigger(21, 1, 1, 0);                                     \
       tr->args[0] = (size_t) CkAllocSysMsg();                                 \
       tr->entries[0] = 15;                                                    \
       tr->refnums[0] = thisIndex.x;                                           \
       __cDep->Register(tr);                                                   \
       return 0;                                                               \
    }                                                                          \
  }                                                                            \
                                                                               \
  void _when_21_end(CkReductionMsg * m) {                                      \
    _slist_34_end();                                                           \
  }                                                                            \
                                                                               \
  void _atomic_43(CkReductionMsg * m) {                                        \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_atomic_43, CkMyPe(), 0, NULL); \
                                                                               \
            double *preVec = (double*) ( m->getData() );                       \
            for (int i = 0; i < BLKSIZE; i++)                                  \
              bvec[i] -= preVec[i];                                            \
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _when_21_end(m);                                                           \
  }                                                                            \
                                                                               \
  void _atomic_44() {                                                          \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, __idx_LUBlk_atomic_44, CkMyPe(), 0, NULL); \
                                                                               \
          localBackward(bvec);                                                 \
          if (thisIndex.x == 0)                                                \
            mainProxy.startNextStep();                                         \
          else {                                                               \
                                                                               \
            CProxySection_LUBlk col = CProxySection_LUBlk::ckNew(thisArrayID,  \
                                                    0, thisIndex.x-1, 1,       \
                                                    thisIndex.y, thisIndex.y, 1);\
            col.beginBackward(BLKSIZE, bvec);                                  \
            thisProxy(thisIndex.x-1, thisIndex.y-1).backwardSolve();           \
          }                                                                    \
                                                                               \
    _TRACE_END_EXECUTE();                                                      \
    _slist_33_end();                                                           \
  }                                                                            \
                                                                               \
public:                                                                        \
  void sendPivotData(int rowIndex, int pivotRow, int size, double *data, double b) {\
    CWhenTrigger *tr;                                                          \
    void* _bgParentLog = NULL;                                                 \
    CMsgBuffer* cmsgbuf;                                                       \
    int impl_off=0; int impl_arrstart=0;                                       \
    int impl_off_data, impl_cnt_data;                                          \
    impl_off_data=impl_off=CK_ALIGN(impl_off,sizeof(double));                  \
    impl_off+=(impl_cnt_data=sizeof(double)*(size));                           \
    {                                                                          \
      PUP::sizer implP1;                                                       \
      implP1|rowIndex;                                                         \
      implP1|pivotRow;                                                         \
      implP1|size;                                                             \
      implP1|impl_off_data;                                                    \
      implP1|b;                                                                \
      impl_arrstart=CK_ALIGN(implP1.size(),16);                                \
      impl_off+=impl_arrstart;                                                 \
    }                                                                          \
    CkMarshallMsg *impl_msg1=CkAllocateMarshallMsg(impl_off,NULL);             \
    {                                                                          \
      PUP::toMem implP1((void *)impl_msg1->msgBuf);                            \
      implP1|rowIndex;                                                         \
      implP1|pivotRow;                                                         \
      implP1|size;                                                             \
      implP1|impl_off_data;                                                    \
      implP1|b;                                                                \
    }                                                                          \
    char *impl_buf1=impl_msg1->msgBuf+impl_arrstart;                           \
    memcpy(impl_buf1+impl_off_data,data,impl_cnt_data);                        \
   cmsgbuf = __cDep->bufferMessage(0,(void *) impl_msg1, (void*) _bgParentLog,rowIndex);\
    tr = __cDep->getTrigger(0,rowIndex);                                       \
    if (tr == 0)                                                               \
      return;                                                                  \
    _TRACE_END_EXECUTE();                                                      \
    switch(tr->whenID) {                                                       \
      case 0:                                                                  \
      {                                                                        \
        CkMarshallMsg *impl_msg0 = (CkMarshallMsg *) tr->args[0];              \
        char *impl_buf0=((CkMarshallMsg *)impl_msg0)->msgBuf;                  \
        PUP::fromMem implP0(impl_buf0);                                        \
        int targetCol; implP0|targetCol;                                       \
        impl_buf0+=CK_ALIGN(implP0.size(),16);                                 \
        delete (CkMarshallMsg *)impl_msg0;                                     \
        _when_0(targetCol);                                                    \
        delete tr;                                                             \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _dummyEP, CkMyPe(), 0, NULL);        \
        return;                                                                \
      }                                                                        \
      case 13:                                                                 \
      {                                                                        \
    CkFreeSysMsg((void  *)tr->args[0]);                                        \
        _when_13((CkReductionMsg *) tr->args[1]);                              \
        delete tr;                                                             \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _dummyEP, CkMyPe(), 0, NULL);        \
        return;                                                                \
      }                                                                        \
    }                                                                          \
  }                                                                            \
                                                                               \
  void applyPivots(pivotSequencesMsg *msg_msg) {                               \
    CWhenTrigger *tr;                                                          \
    void* _bgParentLog = NULL;                                                 \
    CMsgBuffer* cmsgbuf;                                                       \
    CmiReference(UsrToEnv(msg_msg));                                           \
    int refnum = CkGetRefNum(msg_msg);                                         \
    cmsgbuf = __cDep->bufferMessage(1,(void *) msg_msg , (void *) _bgParentLog, refnum);\
    tr = __cDep->getTrigger(1, refnum);                                        \
    if (tr == 0)                                                               \
      return;                                                                  \
    _TRACE_END_EXECUTE();                                                      \
    switch(tr->whenID) {                                                       \
      case 1:                                                                  \
      {                                                                        \
    CkFreeSysMsg((void  *)tr->args[0]);                                        \
        _when_1();                                                             \
        delete tr;                                                             \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _dummyEP, CkMyPe(), 0, NULL);        \
        return;                                                                \
      }                                                                        \
      case 7:                                                                  \
      {                                                                        \
    CkFreeSysMsg((void  *)tr->args[0]);                                        \
        _when_7();                                                             \
        delete tr;                                                             \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _dummyEP, CkMyPe(), 0, NULL);        \
        return;                                                                \
      }                                                                        \
      case 9:                                                                  \
      {                                                                        \
    CkFreeSysMsg((void  *)tr->args[0]);                                        \
        _when_9();                                                             \
        delete tr;                                                             \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _dummyEP, CkMyPe(), 0, NULL);        \
        return;                                                                \
      }                                                                        \
    }                                                                          \
  }                                                                            \
                                                                               \
  void acceptPivotData(pivotRowsMsg *aMsg_msg) {                               \
    CWhenTrigger *tr;                                                          \
    void* _bgParentLog = NULL;                                                 \
    CMsgBuffer* cmsgbuf;                                                       \
    CmiReference(UsrToEnv(aMsg_msg));                                          \
    int refnum = CkGetRefNum(aMsg_msg);                                        \
    cmsgbuf = __cDep->bufferMessage(2,(void *) aMsg_msg , (void *) _bgParentLog, refnum);\
    tr = __cDep->getTrigger(2, refnum);                                        \
    if (tr == 0)                                                               \
      return;                                                                  \
    _TRACE_END_EXECUTE();                                                      \
    switch(tr->whenID) {                                                       \
      case 2:                                                                  \
      {                                                                        \
    CkFreeSysMsg((void  *)tr->args[0]);                                        \
        _when_2((pivotSequencesMsg *) tr->args[1]);                            \
        delete tr;                                                             \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _dummyEP, CkMyPe(), 0, NULL);        \
        return;                                                                \
      }                                                                        \
      case 8:                                                                  \
      {                                                                        \
    CkFreeSysMsg((void  *)tr->args[0]);                                        \
        _when_8((pivotSequencesMsg *) tr->args[1]);                            \
        delete tr;                                                             \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _dummyEP, CkMyPe(), 0, NULL);        \
        return;                                                                \
      }                                                                        \
      case 10:                                                                 \
      {                                                                        \
    CkFreeSysMsg((void  *)tr->args[0]);                                        \
        _when_10((pivotSequencesMsg *) tr->args[1]);                           \
        delete tr;                                                             \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _dummyEP, CkMyPe(), 0, NULL);        \
        return;                                                                \
      }                                                                        \
    }                                                                          \
  }                                                                            \
                                                                               \
  void processTrailingUpdate(int step, intptr_t update_ptr) {                  \
  if (step < 1 || step >= 79) \
    CkPrintf("(%d,%d) SDAG processTrailingUpdate step = %d\n", thisIndex.x, thisIndex.y, step); \
    CWhenTrigger *tr;                                                          \
    void* _bgParentLog = NULL;                                                 \
    CMsgBuffer* cmsgbuf;                                                       \
    int impl_off=0; int impl_arrstart=0;                                       \
    {                                                                          \
      PUP::sizer implP1;                                                       \
      implP1|step;                                                             \
      implP1|update_ptr;                                                       \
      impl_off+=implP1.size();                                                 \
    }                                                                          \
    CkMarshallMsg *impl_msg1=CkAllocateMarshallMsg(impl_off,NULL);             \
    {                                                                          \
      PUP::toMem implP1((void *)impl_msg1->msgBuf);                            \
      implP1|step;                                                             \
      implP1|update_ptr;                                                       \
    }                                                                          \
   cmsgbuf = __cDep->bufferMessage(3,(void *) impl_msg1, (void*) _bgParentLog,step);\
    tr = __cDep->getTrigger(3,step);                                           \
    if (tr == 0)                                                               \
      return;                                                                  \
    _TRACE_END_EXECUTE();                                                      \
    CkFreeSysMsg((void  *)tr->args[0]);                                        \
    _when_3();                                                                 \
    delete tr;                                                                 \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _dummyEP, CkMyPe(), 0, NULL);        \
    return;                                                                    \
  }                                                                            \
                                                                               \
  void performUpdate(int dummy) {                                              \
    CWhenTrigger *tr;                                                          \
    void* _bgParentLog = NULL;                                                 \
    CMsgBuffer* cmsgbuf;                                                       \
    int impl_off=0; int impl_arrstart=0;                                       \
    {                                                                          \
      PUP::sizer implP1;                                                       \
      implP1|dummy;                                                            \
      impl_off+=implP1.size();                                                 \
    }                                                                          \
    CkMarshallMsg *impl_msg1=CkAllocateMarshallMsg(impl_off,NULL);             \
    {                                                                          \
      PUP::toMem implP1((void *)impl_msg1->msgBuf);                            \
      implP1|dummy;                                                            \
    }                                                                          \
    cmsgbuf = __cDep->bufferMessage(4, (void *) impl_msg1, (void*) _bgParentLog, 0);\
    tr = __cDep->getTrigger(4, 0);                                             \
    if (tr == 0)                                                               \
      return;                                                                  \
    _TRACE_END_EXECUTE();                                                      \
    CkFreeSysMsg((void  *)tr->args[0]);                                        \
    _when_4();                                                                 \
    delete tr;                                                                 \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _dummyEP, CkMyPe(), 0, NULL);        \
    return;                                                                    \
  }                                                                            \
                                                                               \
  void sendUSegment(UMsg *anUmsg_msg) {                                        \
    CWhenTrigger *tr;                                                          \
    void* _bgParentLog = NULL;                                                 \
    CMsgBuffer* cmsgbuf;                                                       \
    CmiReference(UsrToEnv(anUmsg_msg));                                        \
    cmsgbuf = __cDep->bufferMessage(5, (void *) anUmsg_msg,  (void *) _bgParentLog, 0);\
    tr = __cDep->getTrigger(5, 0);                                             \
    if (tr == 0)                                                               \
      return;                                                                  \
    _TRACE_END_EXECUTE();                                                      \
    CkFreeSysMsg((void  *)tr->args[0]);                                        \
    _when_5();                                                                 \
    delete tr;                                                                 \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _dummyEP, CkMyPe(), 0, NULL);        \
    return;                                                                    \
  }                                                                            \
                                                                               \
  void blockUsed(int count) {                                                  \
    CWhenTrigger *tr;                                                          \
    void* _bgParentLog = NULL;                                                 \
    CMsgBuffer* cmsgbuf;                                                       \
    int impl_off=0; int impl_arrstart=0;                                       \
    {                                                                          \
      PUP::sizer implP1;                                                       \
      implP1|count;                                                            \
      impl_off+=implP1.size();                                                 \
    }                                                                          \
    CkMarshallMsg *impl_msg1=CkAllocateMarshallMsg(impl_off,NULL);             \
    {                                                                          \
      PUP::toMem implP1((void *)impl_msg1->msgBuf);                            \
      implP1|count;                                                            \
    }                                                                          \
    cmsgbuf = __cDep->bufferMessage(6, (void *) impl_msg1, (void*) _bgParentLog, 0);\
    tr = __cDep->getTrigger(6, 0);                                             \
    if (tr == 0)                                                               \
      return;                                                                  \
    _TRACE_END_EXECUTE();                                                      \
    CkFreeSysMsg((void  *)tr->args[0]);                                        \
    _when_6();                                                                 \
    delete tr;                                                                 \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _dummyEP, CkMyPe(), 0, NULL);        \
    return;                                                                    \
  }                                                                            \
                                                                               \
  void recvL(blkMsg *mL_msg) {                                                 \
    CWhenTrigger *tr;                                                          \
    void* _bgParentLog = NULL;                                                 \
    CMsgBuffer* cmsgbuf;                                                       \
    CmiReference(UsrToEnv(mL_msg));                                            \
    int refnum = CkGetRefNum(mL_msg);                                          \
    cmsgbuf = __cDep->bufferMessage(7,(void *) mL_msg , (void *) _bgParentLog, refnum);\
    tr = __cDep->getTrigger(7, refnum);                                        \
    if (tr == 0)                                                               \
      return;                                                                  \
    _TRACE_END_EXECUTE();                                                      \
    CkFreeSysMsg((void  *)tr->args[0]);                                        \
    _when_11();                                                                \
    delete tr;                                                                 \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _dummyEP, CkMyPe(), 0, NULL);        \
    return;                                                                    \
  }                                                                            \
                                                                               \
  void colMax(CkReductionMsg *m_msg) {                                         \
    CWhenTrigger *tr;                                                          \
    void* _bgParentLog = NULL;                                                 \
    CMsgBuffer* cmsgbuf;                                                       \
    CmiReference(UsrToEnv(m_msg));                                             \
    cmsgbuf = __cDep->bufferMessage(8, (void *) m_msg,  (void *) _bgParentLog, 0);\
    tr = __cDep->getTrigger(8, 0);                                             \
    if (tr == 0)                                                               \
      return;                                                                  \
    _TRACE_END_EXECUTE();                                                      \
    CkFreeSysMsg((void  *)tr->args[0]);                                        \
    _when_12();                                                                \
    delete tr;                                                                 \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _dummyEP, CkMyPe(), 0, NULL);        \
    return;                                                                    \
  }                                                                            \
                                                                               \
  void multicastRedns(int dummy) {                                             \
    CWhenTrigger *tr;                                                          \
    void* _bgParentLog = NULL;                                                 \
    CMsgBuffer* cmsgbuf;                                                       \
    int impl_off=0; int impl_arrstart=0;                                       \
    {                                                                          \
      PUP::sizer implP1;                                                       \
      implP1|dummy;                                                            \
      impl_off+=implP1.size();                                                 \
    }                                                                          \
    CkMarshallMsg *impl_msg1=CkAllocateMarshallMsg(impl_off,NULL);             \
    {                                                                          \
      PUP::toMem implP1((void *)impl_msg1->msgBuf);                            \
      implP1|dummy;                                                            \
    }                                                                          \
    cmsgbuf = __cDep->bufferMessage(9, (void *) impl_msg1, (void*) _bgParentLog, 0);\
    tr = __cDep->getTrigger(9, 0);                                             \
    if (tr == 0)                                                               \
      return;                                                                  \
    _TRACE_END_EXECUTE();                                                      \
    CkMarshallMsg *impl_msg = (CkMarshallMsg *) tr->args[0];                   \
    char *impl_buf=((CkMarshallMsg *)impl_msg)->msgBuf;                        \
    PUP::fromMem implP(impl_buf);                                              \
    LUConfig luCfg; implP|luCfg;                                               \
    CProxy_LUMgr _mgr; implP|_mgr;                                             \
    CProxy_BlockScheduler bs; implP|bs;                                        \
     impl_buf+=CK_ALIGN(implP.size(),16);                                      \
    delete (CkMarshallMsg *)impl_msg;                                          \
    _when_14(luCfg, _mgr, bs);                                                 \
    delete tr;                                                                 \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _dummyEP, CkMyPe(), 0, NULL);        \
    return;                                                                    \
  }                                                                            \
                                                                               \
  void prepareForPivotRedn(rednSetupMsg *msg_msg) {                            \
    CWhenTrigger *tr;                                                          \
    void* _bgParentLog = NULL;                                                 \
    CMsgBuffer* cmsgbuf;                                                       \
    CmiReference(UsrToEnv(msg_msg));                                           \
    cmsgbuf = __cDep->bufferMessage(10, (void *) msg_msg,  (void *) _bgParentLog, 0);\
    tr = __cDep->getTrigger(10, 0);                                            \
    if (tr == 0)                                                               \
      return;                                                                  \
    _TRACE_END_EXECUTE();                                                      \
    CkMarshallMsg *impl_msg = (CkMarshallMsg *) tr->args[0];                   \
    char *impl_buf=((CkMarshallMsg *)impl_msg)->msgBuf;                        \
    PUP::fromMem implP(impl_buf);                                              \
    LUConfig luCfg; implP|luCfg;                                               \
    CProxy_LUMgr _mgr; implP|_mgr;                                             \
    CProxy_BlockScheduler bs; implP|bs;                                        \
    int dummy; implP|dummy;                                                    \
     impl_buf+=CK_ALIGN(implP.size(),16);                                      \
    delete (CkMarshallMsg *)impl_msg;                                          \
    _when_15(luCfg, _mgr, bs, dummy);                                          \
    delete tr;                                                                 \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _dummyEP, CkMyPe(), 0, NULL);        \
    return;                                                                    \
  }                                                                            \
                                                                               \
  void prepareForRowAfterDiag(rednSetupMsg *msg_msg) {                         \
    CWhenTrigger *tr;                                                          \
    void* _bgParentLog = NULL;                                                 \
    CMsgBuffer* cmsgbuf;                                                       \
    CmiReference(UsrToEnv(msg_msg));                                           \
    cmsgbuf = __cDep->bufferMessage(11, (void *) msg_msg,  (void *) _bgParentLog, 0);\
    tr = __cDep->getTrigger(11, 0);                                            \
    if (tr == 0)                                                               \
      return;                                                                  \
    _TRACE_END_EXECUTE();                                                      \
    CkMarshallMsg *impl_msg = (CkMarshallMsg *) tr->args[0];                   \
    char *impl_buf=((CkMarshallMsg *)impl_msg)->msgBuf;                        \
    PUP::fromMem implP(impl_buf);                                              \
    LUConfig luCfg; implP|luCfg;                                               \
    CProxy_LUMgr _mgr; implP|_mgr;                                             \
    CProxy_BlockScheduler bs; implP|bs;                                        \
    int dummy; implP|dummy;                                                    \
     impl_buf+=CK_ALIGN(implP.size(),16);                                      \
    delete (CkMarshallMsg *)impl_msg;                                          \
    _when_16(luCfg, _mgr, bs, dummy);                                          \
    delete tr;                                                                 \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _dummyEP, CkMyPe(), 0, NULL);        \
    return;                                                                    \
  }                                                                            \
                                                                               \
  void prepareForRowBeforeDiag(rednSetupMsg *msg_msg) {                        \
    CWhenTrigger *tr;                                                          \
    void* _bgParentLog = NULL;                                                 \
    CMsgBuffer* cmsgbuf;                                                       \
    CmiReference(UsrToEnv(msg_msg));                                           \
    cmsgbuf = __cDep->bufferMessage(12, (void *) msg_msg,  (void *) _bgParentLog, 0);\
    tr = __cDep->getTrigger(12, 0);                                            \
    if (tr == 0)                                                               \
      return;                                                                  \
    _TRACE_END_EXECUTE();                                                      \
    CkMarshallMsg *impl_msg = (CkMarshallMsg *) tr->args[0];                   \
    char *impl_buf=((CkMarshallMsg *)impl_msg)->msgBuf;                        \
    PUP::fromMem implP(impl_buf);                                              \
    LUConfig luCfg; implP|luCfg;                                               \
    CProxy_LUMgr _mgr; implP|_mgr;                                             \
    CProxy_BlockScheduler bs; implP|bs;                                        \
    int dummy; implP|dummy;                                                    \
     impl_buf+=CK_ALIGN(implP.size(),16);                                      \
    delete (CkMarshallMsg *)impl_msg;                                          \
    _when_17(luCfg, _mgr, bs, dummy);                                          \
    delete tr;                                                                 \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _dummyEP, CkMyPe(), 0, NULL);        \
    return;                                                                    \
  }                                                                            \
                                                                               \
  void prepareForPivotLR(rednSetupMsg *msg_msg) {                              \
    CWhenTrigger *tr;                                                          \
    void* _bgParentLog = NULL;                                                 \
    CMsgBuffer* cmsgbuf;                                                       \
    CmiReference(UsrToEnv(msg_msg));                                           \
    cmsgbuf = __cDep->bufferMessage(13, (void *) msg_msg,  (void *) _bgParentLog, 0);\
    tr = __cDep->getTrigger(13, 0);                                            \
    if (tr == 0)                                                               \
      return;                                                                  \
    _TRACE_END_EXECUTE();                                                      \
    CkMarshallMsg *impl_msg = (CkMarshallMsg *) tr->args[0];                   \
    char *impl_buf=((CkMarshallMsg *)impl_msg)->msgBuf;                        \
    PUP::fromMem implP(impl_buf);                                              \
    LUConfig luCfg; implP|luCfg;                                               \
    CProxy_LUMgr _mgr; implP|_mgr;                                             \
    CProxy_BlockScheduler bs; implP|bs;                                        \
    int dummy; implP|dummy;                                                    \
     impl_buf+=CK_ALIGN(implP.size(),16);                                      \
    delete (CkMarshallMsg *)impl_msg;                                          \
    _when_18(luCfg, _mgr, bs, dummy);                                          \
    delete tr;                                                                 \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _dummyEP, CkMyPe(), 0, NULL);        \
    return;                                                                    \
  }                                                                            \
                                                                               \
  void prepareForMulticastL(rednSetupMsg *msg_msg) {                           \
    CWhenTrigger *tr;                                                          \
    void* _bgParentLog = NULL;                                                 \
    CMsgBuffer* cmsgbuf;                                                       \
    CmiReference(UsrToEnv(msg_msg));                                           \
    cmsgbuf = __cDep->bufferMessage(14, (void *) msg_msg,  (void *) _bgParentLog, 0);\
    tr = __cDep->getTrigger(14, 0);                                            \
    if (tr == 0)                                                               \
      return;                                                                  \
    _TRACE_END_EXECUTE();                                                      \
    CkMarshallMsg *impl_msg = (CkMarshallMsg *) tr->args[0];                   \
    char *impl_buf=((CkMarshallMsg *)impl_msg)->msgBuf;                        \
    PUP::fromMem implP(impl_buf);                                              \
    LUConfig luCfg; implP|luCfg;                                               \
    CProxy_LUMgr _mgr; implP|_mgr;                                             \
    CProxy_BlockScheduler bs; implP|bs;                                        \
    int dummy; implP|dummy;                                                    \
     impl_buf+=CK_ALIGN(implP.size(),16);                                      \
    delete (CkMarshallMsg *)impl_msg;                                          \
    _when_19(luCfg, _mgr, bs, dummy);                                          \
    delete tr;                                                                 \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _dummyEP, CkMyPe(), 0, NULL);        \
    return;                                                                    \
  }                                                                            \
                                                                               \
  void recvSolveData(CkReductionMsg *m_msg) {                                  \
    CWhenTrigger *tr;                                                          \
    void* _bgParentLog = NULL;                                                 \
    CMsgBuffer* cmsgbuf;                                                       \
    CmiReference(UsrToEnv(m_msg));                                             \
    int refnum = CkGetRefNum(m_msg);                                           \
    cmsgbuf = __cDep->bufferMessage(15,(void *) m_msg , (void *) _bgParentLog, refnum);\
    tr = __cDep->getTrigger(15, refnum);                                       \
    if (tr == 0)                                                               \
      return;                                                                  \
    _TRACE_END_EXECUTE();                                                      \
    switch(tr->whenID) {                                                       \
      case 20:                                                                 \
      {                                                                        \
    CkFreeSysMsg((void  *)tr->args[0]);                                        \
        _when_20();                                                            \
        delete tr;                                                             \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _dummyEP, CkMyPe(), 0, NULL);        \
        return;                                                                \
      }                                                                        \
      case 21:                                                                 \
      {                                                                        \
    CkFreeSysMsg((void  *)tr->args[0]);                                        \
        _when_21();                                                            \
        delete tr;                                                             \
    _TRACE_BEGIN_EXECUTE_DETAILED(-1, -1, _dummyEP, CkMyPe(), 0, NULL);        \
        return;                                                                \
      }                                                                        \
    }                                                                          \
  }                                                                            \
                                                                               \
private:                                                                       \
  CDep *__cDep;                                                                \
  void __sdag_init(void) {                                                     \
    __cDep = new CDep(16,22);                                                  \
    __cDep->addDepends(0,0);                                                   \
    __cDep->addDepends(13,0);                                                  \
    __cDep->addDepends(1,1);                                                   \
    __cDep->addDepends(7,1);                                                   \
    __cDep->addDepends(9,1);                                                   \
    __cDep->addDepends(2,2);                                                   \
    __cDep->addDepends(8,2);                                                   \
    __cDep->addDepends(10,2);                                                  \
    __cDep->addDepends(3,3);                                                   \
    __cDep->addDepends(4,4);                                                   \
    __cDep->addDepends(5,5);                                                   \
    __cDep->addDepends(6,6);                                                   \
    __cDep->addDepends(11,7);                                                  \
    __cDep->addDepends(12,8);                                                  \
    __cDep->addDepends(14,9);                                                  \
    __cDep->addDepends(15,10);                                                 \
    __cDep->addDepends(16,11);                                                 \
    __cDep->addDepends(17,12);                                                 \
    __cDep->addDepends(18,13);                                                 \
    __cDep->addDepends(19,14);                                                 \
    __cDep->addDepends(20,15);                                                 \
    __cDep->addDepends(21,15);                                                 \
  }                                                                            \
public:                                                                        \
  void __sdag_pup(PUP::er& p) {                                                \
    if (__cDep) { __cDep->pup(p); }                                            \
  }                                                                            \
  static void __sdag_register() {                                              \
                                                                               \
    __idx_LUBlk_below_send_remote_pivot = CkRegisterEp("LUBlk_below_send_remote_pivot(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_below_send_useg = CkRegisterEp("LUBlk_below_send_useg(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_below_recv_remote_pivot = CkRegisterEp("LUBlk_below_recv_remote_pivot(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_atomic_3 = CkRegisterEp("LUBlk_atomic_3(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_sendOutgoingPivots_trailingChare = CkRegisterEp("LUBlk_sendOutgoingPivots_trailingChare(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_acceptIncomingPivots_trailingChare = CkRegisterEp("LUBlk_acceptIncomingPivots_trailingChare(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_atomic_6 = CkRegisterEp("LUBlk_atomic_6(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_trailing_update = CkRegisterEp("LUBlk_trailing_update(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_atomic_22 = CkRegisterEp("LUBlk_atomic_22(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_sendOutgoingPivots_activeRowChare = CkRegisterEp("LUBlk_sendOutgoingPivots_activeRowChare(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_acceptIncomingPivots_activeRowChare = CkRegisterEp("LUBlk_acceptIncomingPivots_activeRowChare(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_atomic_20 = CkRegisterEp("LUBlk_atomic_20(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_beforeL_schedule_computeU = CkRegisterEp("LUBlk_beforeL_schedule_computeU(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_atomic_8 = CkRegisterEp("LUBlk_atomic_8(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_below_find_pivot = CkRegisterEp("LUBlk_below_find_pivot(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_useg_delayed_update = CkRegisterEp("LUBlk_useg_delayed_update(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_atomic_11 = CkRegisterEp("LUBlk_atomic_11(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_below_recv_useg = CkRegisterEp("LUBlk_below_recv_useg(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_below_send_L = CkRegisterEp("LUBlk_below_send_L(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_atomic_14 = CkRegisterEp("LUBlk_atomic_14(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_sendOutgoingPivots_leftSectionChare = CkRegisterEp("LUBlk_sendOutgoingPivots_leftSectionChare(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_acceptIncomingPivots_leftSectionChare = CkRegisterEp("LUBlk_acceptIncomingPivots_leftSectionChare(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_atomic_17 = CkRegisterEp("LUBlk_atomic_17(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_offdiag_iteration_completed = CkRegisterEp("LUBlk_offdiag_iteration_completed(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_atomic_24 = CkRegisterEp("LUBlk_atomic_24(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_diag_find_colmax = CkRegisterEp("LUBlk_diag_find_colmax(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_diag_found_colmax = CkRegisterEp("LUBlk_diag_found_colmax(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_diag_send_useg = CkRegisterEp("LUBlk_diag_send_useg(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_diag_local_pivot = CkRegisterEp("LUBlk_diag_local_pivot(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_diag_send_remote_pivot = CkRegisterEp("LUBlk_diag_send_remote_pivot(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_diag_receive_remote_pivot = CkRegisterEp("LUBlk_diag_receive_remote_pivot(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_diag_agglomerate_pivots = CkRegisterEp("LUBlk_diag_agglomerate_pivots(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_diag_update = CkRegisterEp("LUBlk_diag_update(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_diag_multicast_L = CkRegisterEp("LUBlk_diag_multicast_L(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_atomic_34 = CkRegisterEp("LUBlk_atomic_34(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_atomic_35 = CkRegisterEp("LUBlk_atomic_35(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_atomic_37 = CkRegisterEp("LUBlk_atomic_37(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_atomic_36 = CkRegisterEp("LUBlk_atomic_36(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_atomic_38 = CkRegisterEp("LUBlk_atomic_38(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_atomic_39 = CkRegisterEp("LUBlk_atomic_39(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_atomic_40 = CkRegisterEp("LUBlk_atomic_40(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_atomic_41 = CkRegisterEp("LUBlk_atomic_41(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_atomic_42 = CkRegisterEp("LUBlk_atomic_42(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_atomic_43 = CkRegisterEp("LUBlk_atomic_43(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
    __idx_LUBlk_atomic_44 = CkRegisterEp("LUBlk_atomic_44(void)", NULL, 0, CkIndex_LUBlk::__idx, 0);\
  }                                                                            \
  static int __idx_LUBlk_below_send_remote_pivot;                              \
  static int __idx_LUBlk_below_send_useg;                                      \
  static int __idx_LUBlk_below_recv_remote_pivot;                              \
  static int __idx_LUBlk_atomic_3;                                             \
  static int __idx_LUBlk_sendOutgoingPivots_trailingChare;                     \
  static int __idx_LUBlk_acceptIncomingPivots_trailingChare;                   \
  static int __idx_LUBlk_atomic_6;                                             \
  static int __idx_LUBlk_trailing_update;                                      \
  static int __idx_LUBlk_atomic_22;                                            \
  static int __idx_LUBlk_sendOutgoingPivots_activeRowChare;                    \
  static int __idx_LUBlk_acceptIncomingPivots_activeRowChare;                  \
  static int __idx_LUBlk_atomic_20;                                            \
  static int __idx_LUBlk_beforeL_schedule_computeU;                            \
  static int __idx_LUBlk_atomic_8;                                             \
  static int __idx_LUBlk_below_find_pivot;                                     \
  static int __idx_LUBlk_useg_delayed_update;                                  \
  static int __idx_LUBlk_atomic_11;                                            \
  static int __idx_LUBlk_below_recv_useg;                                      \
  static int __idx_LUBlk_below_send_L;                                         \
  static int __idx_LUBlk_atomic_14;                                            \
  static int __idx_LUBlk_sendOutgoingPivots_leftSectionChare;                  \
  static int __idx_LUBlk_acceptIncomingPivots_leftSectionChare;                \
  static int __idx_LUBlk_atomic_17;                                            \
  static int __idx_LUBlk_offdiag_iteration_completed;                          \
  static int __idx_LUBlk_atomic_24;                                            \
  static int __idx_LUBlk_diag_find_colmax;                                     \
  static int __idx_LUBlk_diag_found_colmax;                                    \
  static int __idx_LUBlk_diag_send_useg;                                       \
  static int __idx_LUBlk_diag_local_pivot;                                     \
  static int __idx_LUBlk_diag_send_remote_pivot;                               \
  static int __idx_LUBlk_diag_receive_remote_pivot;                            \
  static int __idx_LUBlk_diag_agglomerate_pivots;                              \
  static int __idx_LUBlk_diag_update;                                          \
  static int __idx_LUBlk_diag_multicast_L;                                     \
  static int __idx_LUBlk_atomic_34;                                            \
  static int __idx_LUBlk_atomic_35;                                            \
  static int __idx_LUBlk_atomic_37;                                            \
  static int __idx_LUBlk_atomic_36;                                            \
  static int __idx_LUBlk_atomic_38;                                            \
  static int __idx_LUBlk_atomic_39;                                            \
  static int __idx_LUBlk_atomic_40;                                            \
  static int __idx_LUBlk_atomic_41;                                            \
  static int __idx_LUBlk_atomic_42;                                            \
  static int __idx_LUBlk_atomic_43;                                            \
  static int __idx_LUBlk_atomic_44;                                            \

#define LUBlk_SDAG_CODE_DEF \
  int LUBlk::__idx_LUBlk_below_send_remote_pivot=0;\
  int LUBlk::__idx_LUBlk_below_send_useg=0;\
  int LUBlk::__idx_LUBlk_below_recv_remote_pivot=0;\
  int LUBlk::__idx_LUBlk_atomic_3=0;\
  int LUBlk::__idx_LUBlk_sendOutgoingPivots_trailingChare=0;\
  int LUBlk::__idx_LUBlk_acceptIncomingPivots_trailingChare=0;\
  int LUBlk::__idx_LUBlk_atomic_6=0;\
  int LUBlk::__idx_LUBlk_trailing_update=0;\
  int LUBlk::__idx_LUBlk_atomic_22=0;\
  int LUBlk::__idx_LUBlk_sendOutgoingPivots_activeRowChare=0;\
  int LUBlk::__idx_LUBlk_acceptIncomingPivots_activeRowChare=0;\
  int LUBlk::__idx_LUBlk_atomic_20=0;\
  int LUBlk::__idx_LUBlk_beforeL_schedule_computeU=0;\
  int LUBlk::__idx_LUBlk_atomic_8=0;\
  int LUBlk::__idx_LUBlk_below_find_pivot=0;\
  int LUBlk::__idx_LUBlk_useg_delayed_update=0;\
  int LUBlk::__idx_LUBlk_atomic_11=0;\
  int LUBlk::__idx_LUBlk_below_recv_useg=0;\
  int LUBlk::__idx_LUBlk_below_send_L=0;\
  int LUBlk::__idx_LUBlk_atomic_14=0;\
  int LUBlk::__idx_LUBlk_sendOutgoingPivots_leftSectionChare=0;\
  int LUBlk::__idx_LUBlk_acceptIncomingPivots_leftSectionChare=0;\
  int LUBlk::__idx_LUBlk_atomic_17=0;\
  int LUBlk::__idx_LUBlk_offdiag_iteration_completed=0;\
  int LUBlk::__idx_LUBlk_atomic_24=0;\
  int LUBlk::__idx_LUBlk_diag_find_colmax=0;\
  int LUBlk::__idx_LUBlk_diag_found_colmax=0;\
  int LUBlk::__idx_LUBlk_diag_send_useg=0;\
  int LUBlk::__idx_LUBlk_diag_local_pivot=0;\
  int LUBlk::__idx_LUBlk_diag_send_remote_pivot=0;\
  int LUBlk::__idx_LUBlk_diag_receive_remote_pivot=0;\
  int LUBlk::__idx_LUBlk_diag_agglomerate_pivots=0;\
  int LUBlk::__idx_LUBlk_diag_update=0;\
  int LUBlk::__idx_LUBlk_diag_multicast_L=0;\
  int LUBlk::__idx_LUBlk_atomic_34=0;\
  int LUBlk::__idx_LUBlk_atomic_35=0;\
  int LUBlk::__idx_LUBlk_atomic_37=0;\
  int LUBlk::__idx_LUBlk_atomic_36=0;\
  int LUBlk::__idx_LUBlk_atomic_38=0;\
  int LUBlk::__idx_LUBlk_atomic_39=0;\
  int LUBlk::__idx_LUBlk_atomic_40=0;\
  int LUBlk::__idx_LUBlk_atomic_41=0;\
  int LUBlk::__idx_LUBlk_atomic_42=0;\
  int LUBlk::__idx_LUBlk_atomic_43=0;\
  int LUBlk::__idx_LUBlk_atomic_44=0;\

typedef CBaseT1<ArrayElementT<CkIndex2D>, CProxy_LUBlk> CBase_LUBlk;

/* DECLS: group BlockScheduler: IrrGroup{
BlockScheduler(const CProxy_LUBlk &luArr, const LUConfig &config);
void deliverBlock(blkMsg* impl_msg);
void printBlockLimit(void);
void allRegistered(CkReductionMsg* impl_msg);
};
 */
 class BlockScheduler;
 class CkIndex_BlockScheduler;
 class CProxy_BlockScheduler;
 class CProxyElement_BlockScheduler;
 class CProxySection_BlockScheduler;
/* --------------- index object ------------------ */
class CkIndex_BlockScheduler:public CProxyElement_IrrGroup{
  public:
    typedef BlockScheduler local_t;
    typedef CkIndex_BlockScheduler index_t;
    typedef CProxy_BlockScheduler proxy_t;
    typedef CProxyElement_BlockScheduler element_t;
    typedef CProxySection_BlockScheduler section_t;

    static int __idx;
    static void __register(const char *s, size_t size);
/* DECLS: BlockScheduler(const CProxy_LUBlk &luArr, const LUConfig &config);
 */
    static int __idx_BlockScheduler_marshall1;
    static int ckNew(const CProxy_LUBlk &luArr, const LUConfig &config) { return __idx_BlockScheduler_marshall1; }
    static void _call_BlockScheduler_marshall1(void* impl_msg,BlockScheduler* impl_obj);
    static int _callmarshall_BlockScheduler_marshall1(char* impl_buf,BlockScheduler* impl_obj);
    static void _marshallmessagepup_BlockScheduler_marshall1(PUP::er &p,void *msg);

/* DECLS: void deliverBlock(blkMsg* impl_msg);
 */
    static int __idx_deliverBlock_blkMsg;
    static int deliverBlock(blkMsg* impl_msg) { return __idx_deliverBlock_blkMsg; }
    static void _call_deliverBlock_blkMsg(void* impl_msg,BlockScheduler* impl_obj);

/* DECLS: void printBlockLimit(void);
 */
    static int __idx_printBlockLimit_void;
    static int printBlockLimit(void) { return __idx_printBlockLimit_void; }
    static void _call_printBlockLimit_void(void* impl_msg,BlockScheduler* impl_obj);

/* DECLS: void allRegistered(CkReductionMsg* impl_msg);
 */
    static int __idx_allRegistered_CkReductionMsg;
    static int allRegistered(CkReductionMsg* impl_msg) { return __idx_allRegistered_CkReductionMsg; }
    static void _call_allRegistered_CkReductionMsg(void* impl_msg,BlockScheduler* impl_obj);

};
/* --------------- element proxy ------------------ */
class CProxyElement_BlockScheduler: public CProxyElement_IrrGroup{
  public:
    typedef BlockScheduler local_t;
    typedef CkIndex_BlockScheduler index_t;
    typedef CProxy_BlockScheduler proxy_t;
    typedef CProxyElement_BlockScheduler element_t;
    typedef CProxySection_BlockScheduler section_t;

    CProxyElement_BlockScheduler(void) {}
    CProxyElement_BlockScheduler(const IrrGroup *g) : CProxyElement_IrrGroup(g){  }
    CProxyElement_BlockScheduler(CkGroupID _gid,int _onPE,CK_DELCTOR_PARAM) : CProxyElement_IrrGroup(_gid,_onPE,CK_DELCTOR_ARGS){  }
    CProxyElement_BlockScheduler(CkGroupID _gid,int _onPE) : CProxyElement_IrrGroup(_gid,_onPE){  }
int ckIsDelegated(void) const {return CProxyElement_IrrGroup::ckIsDelegated();}
inline CkDelegateMgr *ckDelegatedTo(void) const {return CProxyElement_IrrGroup::ckDelegatedTo();}
inline CkDelegateData *ckDelegatedPtr(void) const {return CProxyElement_IrrGroup::ckDelegatedPtr();}
CkGroupID ckDelegatedIdx(void) const {return CProxyElement_IrrGroup::ckDelegatedIdx();}
inline void ckCheck(void) const {CProxyElement_IrrGroup::ckCheck();}
CkChareID ckGetChareID(void) const
   {return CProxyElement_IrrGroup::ckGetChareID();}
CkGroupID ckGetGroupID(void) const
   {return CProxyElement_IrrGroup::ckGetGroupID();}
operator CkGroupID () const { return ckGetGroupID(); }
inline void setReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxyElement_IrrGroup::setReductionClient(fn,param); }
inline void ckSetReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxyElement_IrrGroup::ckSetReductionClient(fn,param); }
inline void ckSetReductionClient(CkCallback *cb) const
{ CProxyElement_IrrGroup::ckSetReductionClient(cb); }
int ckGetGroupPe(void) const
{return CProxyElement_IrrGroup::ckGetGroupPe();}
    void ckDelegate(CkDelegateMgr *dTo,CkDelegateData *dPtr=NULL) {
      CProxyElement_IrrGroup::ckDelegate(dTo,dPtr);
    }
    void ckUndelegate(void) {
      CProxyElement_IrrGroup::ckUndelegate();
    }
    void pup(PUP::er &p) {
      CProxyElement_IrrGroup::pup(p);
    }
    void ckSetGroupID(CkGroupID g) {
      CProxyElement_IrrGroup::ckSetGroupID(g);
    }
    BlockScheduler* ckLocalBranch(void) const {
      return ckLocalBranch(ckGetGroupID());
    }
    static BlockScheduler* ckLocalBranch(CkGroupID gID) {
      return (BlockScheduler*)CkLocalBranch(gID);
    }
/* DECLS: BlockScheduler(const CProxy_LUBlk &luArr, const LUConfig &config);
 */

/* DECLS: void deliverBlock(blkMsg* impl_msg);
 */
    void deliverBlock(blkMsg* impl_msg);

/* DECLS: void printBlockLimit(void);
 */
    void printBlockLimit(void);

/* DECLS: void allRegistered(CkReductionMsg* impl_msg);
 */
    void allRegistered(CkReductionMsg* impl_msg);

};
PUPmarshall(CProxyElement_BlockScheduler)
/* ---------------- collective proxy -------------- */
class CProxy_BlockScheduler: public CProxy_IrrGroup{
  public:
    typedef BlockScheduler local_t;
    typedef CkIndex_BlockScheduler index_t;
    typedef CProxy_BlockScheduler proxy_t;
    typedef CProxyElement_BlockScheduler element_t;
    typedef CProxySection_BlockScheduler section_t;

    CProxy_BlockScheduler(void) {}
    CProxy_BlockScheduler(const IrrGroup *g) : CProxy_IrrGroup(g){  }
    CProxy_BlockScheduler(CkGroupID _gid,CK_DELCTOR_PARAM) : CProxy_IrrGroup(_gid,CK_DELCTOR_ARGS){  }
    CProxy_BlockScheduler(CkGroupID _gid) : CProxy_IrrGroup(_gid){  }
    CProxyElement_BlockScheduler operator[](int onPE) const
      {return CProxyElement_BlockScheduler(ckGetGroupID(),onPE,CK_DELCTOR_CALL);}
int ckIsDelegated(void) const {return CProxy_IrrGroup::ckIsDelegated();}
inline CkDelegateMgr *ckDelegatedTo(void) const {return CProxy_IrrGroup::ckDelegatedTo();}
inline CkDelegateData *ckDelegatedPtr(void) const {return CProxy_IrrGroup::ckDelegatedPtr();}
CkGroupID ckDelegatedIdx(void) const {return CProxy_IrrGroup::ckDelegatedIdx();}
inline void ckCheck(void) const {CProxy_IrrGroup::ckCheck();}
CkChareID ckGetChareID(void) const
   {return CProxy_IrrGroup::ckGetChareID();}
CkGroupID ckGetGroupID(void) const
   {return CProxy_IrrGroup::ckGetGroupID();}
operator CkGroupID () const { return ckGetGroupID(); }
inline void setReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxy_IrrGroup::setReductionClient(fn,param); }
inline void ckSetReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxy_IrrGroup::ckSetReductionClient(fn,param); }
inline void ckSetReductionClient(CkCallback *cb) const
{ CProxy_IrrGroup::ckSetReductionClient(cb); }
    void ckDelegate(CkDelegateMgr *dTo,CkDelegateData *dPtr=NULL) {
      CProxy_IrrGroup::ckDelegate(dTo,dPtr);
    }
    void ckUndelegate(void) {
      CProxy_IrrGroup::ckUndelegate();
    }
    void pup(PUP::er &p) {
      CProxy_IrrGroup::pup(p);
    }
    void ckSetGroupID(CkGroupID g) {
      CProxy_IrrGroup::ckSetGroupID(g);
    }
    BlockScheduler* ckLocalBranch(void) const {
      return ckLocalBranch(ckGetGroupID());
    }
    static BlockScheduler* ckLocalBranch(CkGroupID gID) {
      return (BlockScheduler*)CkLocalBranch(gID);
    }
/* DECLS: BlockScheduler(const CProxy_LUBlk &luArr, const LUConfig &config);
 */
    static CkGroupID ckNew(const CProxy_LUBlk &luArr, const LUConfig &config, const CkEntryOptions *impl_e_opts=NULL);
    CProxy_BlockScheduler(const CProxy_LUBlk &luArr, const LUConfig &config, const CkEntryOptions *impl_e_opts=NULL);

/* DECLS: void deliverBlock(blkMsg* impl_msg);
 */
    void deliverBlock(blkMsg* impl_msg);
    void deliverBlock(blkMsg* impl_msg, int npes, int *pes);
    void deliverBlock(blkMsg* impl_msg, CmiGroup &grp);

/* DECLS: void printBlockLimit(void);
 */
    void printBlockLimit(void);
    void printBlockLimit(int npes, int *pes);
    void printBlockLimit(CmiGroup &grp);

/* DECLS: void allRegistered(CkReductionMsg* impl_msg);
 */
    void allRegistered(CkReductionMsg* impl_msg);
    void allRegistered(CkReductionMsg* impl_msg, int npes, int *pes);
    void allRegistered(CkReductionMsg* impl_msg, CmiGroup &grp);

};
PUPmarshall(CProxy_BlockScheduler)
/* ---------------- section proxy -------------- */
class CProxySection_BlockScheduler: public CProxySection_IrrGroup{
  public:
    typedef BlockScheduler local_t;
    typedef CkIndex_BlockScheduler index_t;
    typedef CProxy_BlockScheduler proxy_t;
    typedef CProxyElement_BlockScheduler element_t;
    typedef CProxySection_BlockScheduler section_t;

    CProxySection_BlockScheduler(void) {}
    CProxySection_BlockScheduler(const IrrGroup *g) : CProxySection_IrrGroup(g){  }
    CProxySection_BlockScheduler(const CkGroupID &_gid,const int *_pelist,int _npes,CK_DELCTOR_PARAM) : CProxySection_IrrGroup(_gid,_pelist,_npes,CK_DELCTOR_ARGS){  }
    CProxySection_BlockScheduler(const CkGroupID &_gid,const int *_pelist,int _npes) : CProxySection_IrrGroup(_gid,_pelist,_npes){  }
    CProxySection_BlockScheduler(int n,const CkGroupID *_gid, int const * const *_pelist,const int *_npes) : CProxySection_IrrGroup(n,_gid,_pelist,_npes){  }
    CProxySection_BlockScheduler(int n,const CkGroupID *_gid, int const * const *_pelist,const int *_npes,CK_DELCTOR_PARAM) : CProxySection_IrrGroup(n,_gid,_pelist,_npes,CK_DELCTOR_ARGS){  }
int ckIsDelegated(void) const {return CProxySection_IrrGroup::ckIsDelegated();}
inline CkDelegateMgr *ckDelegatedTo(void) const {return CProxySection_IrrGroup::ckDelegatedTo();}
inline CkDelegateData *ckDelegatedPtr(void) const {return CProxySection_IrrGroup::ckDelegatedPtr();}
CkGroupID ckDelegatedIdx(void) const {return CProxySection_IrrGroup::ckDelegatedIdx();}
inline void ckCheck(void) const {CProxySection_IrrGroup::ckCheck();}
CkChareID ckGetChareID(void) const
   {return CProxySection_IrrGroup::ckGetChareID();}
CkGroupID ckGetGroupID(void) const
   {return CProxySection_IrrGroup::ckGetGroupID();}
operator CkGroupID () const { return ckGetGroupID(); }
inline void setReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxySection_IrrGroup::setReductionClient(fn,param); }
inline void ckSetReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxySection_IrrGroup::ckSetReductionClient(fn,param); }
inline void ckSetReductionClient(CkCallback *cb) const
{ CProxySection_IrrGroup::ckSetReductionClient(cb); }
inline int ckGetNumSections() const
{ return CProxySection_IrrGroup::ckGetNumSections(); }
inline CkSectionInfo &ckGetSectionInfo()
{ return CProxySection_IrrGroup::ckGetSectionInfo(); }
inline CkSectionID *ckGetSectionIDs()
{ return CProxySection_IrrGroup::ckGetSectionIDs(); }
inline CkSectionID &ckGetSectionID()
{ return CProxySection_IrrGroup::ckGetSectionID(); }
inline CkSectionID &ckGetSectionID(int i)
{ return CProxySection_IrrGroup::ckGetSectionID(i); }
inline CkGroupID ckGetGroupIDn(int i) const
{ return CProxySection_IrrGroup::ckGetGroupIDn(i); }
inline int *ckGetElements() const
{ return CProxySection_IrrGroup::ckGetElements(); }
inline int *ckGetElements(int i) const
{ return CProxySection_IrrGroup::ckGetElements(i); }
inline int ckGetNumElements() const
{ return CProxySection_IrrGroup::ckGetNumElements(); } 
inline int ckGetNumElements(int i) const
{ return CProxySection_IrrGroup::ckGetNumElements(i); }
    void ckDelegate(CkDelegateMgr *dTo,CkDelegateData *dPtr=NULL) {
      CProxySection_IrrGroup::ckDelegate(dTo,dPtr);
    }
    void ckUndelegate(void) {
      CProxySection_IrrGroup::ckUndelegate();
    }
    void pup(PUP::er &p) {
      CProxySection_IrrGroup::pup(p);
    }
    void ckSetGroupID(CkGroupID g) {
      CProxySection_IrrGroup::ckSetGroupID(g);
    }
    BlockScheduler* ckLocalBranch(void) const {
      return ckLocalBranch(ckGetGroupID());
    }
    static BlockScheduler* ckLocalBranch(CkGroupID gID) {
      return (BlockScheduler*)CkLocalBranch(gID);
    }
/* DECLS: BlockScheduler(const CProxy_LUBlk &luArr, const LUConfig &config);
 */

/* DECLS: void deliverBlock(blkMsg* impl_msg);
 */
    void deliverBlock(blkMsg* impl_msg);

/* DECLS: void printBlockLimit(void);
 */
    void printBlockLimit(void);

/* DECLS: void allRegistered(CkReductionMsg* impl_msg);
 */
    void allRegistered(CkReductionMsg* impl_msg);

};
PUPmarshall(CProxySection_BlockScheduler)
typedef CBaseT1<Group, CProxy_BlockScheduler> CBase_BlockScheduler;

/* DECLS: group BlockCyclicMap: CkArrayMap{
BlockCyclicMap(void);
};
 */
 class BlockCyclicMap;
 class CkIndex_BlockCyclicMap;
 class CProxy_BlockCyclicMap;
 class CProxyElement_BlockCyclicMap;
 class CProxySection_BlockCyclicMap;
/* --------------- index object ------------------ */
class CkIndex_BlockCyclicMap:public CProxyElement_CkArrayMap{
  public:
    typedef BlockCyclicMap local_t;
    typedef CkIndex_BlockCyclicMap index_t;
    typedef CProxy_BlockCyclicMap proxy_t;
    typedef CProxyElement_BlockCyclicMap element_t;
    typedef CProxySection_BlockCyclicMap section_t;

    static int __idx;
    static void __register(const char *s, size_t size);
/* DECLS: BlockCyclicMap(void);
 */
    static int __idx_BlockCyclicMap_void;
    static int ckNew(void) { return __idx_BlockCyclicMap_void; }
    static void _call_BlockCyclicMap_void(void* impl_msg,BlockCyclicMap* impl_obj);

};
/* --------------- element proxy ------------------ */
class CProxyElement_BlockCyclicMap: public CProxyElement_CkArrayMap{
  public:
    typedef BlockCyclicMap local_t;
    typedef CkIndex_BlockCyclicMap index_t;
    typedef CProxy_BlockCyclicMap proxy_t;
    typedef CProxyElement_BlockCyclicMap element_t;
    typedef CProxySection_BlockCyclicMap section_t;

    CProxyElement_BlockCyclicMap(void) {}
    CProxyElement_BlockCyclicMap(const IrrGroup *g) : CProxyElement_CkArrayMap(g){  }
    CProxyElement_BlockCyclicMap(CkGroupID _gid,int _onPE,CK_DELCTOR_PARAM) : CProxyElement_CkArrayMap(_gid,_onPE,CK_DELCTOR_ARGS){  }
    CProxyElement_BlockCyclicMap(CkGroupID _gid,int _onPE) : CProxyElement_CkArrayMap(_gid,_onPE){  }
int ckIsDelegated(void) const {return CProxyElement_CkArrayMap::ckIsDelegated();}
inline CkDelegateMgr *ckDelegatedTo(void) const {return CProxyElement_CkArrayMap::ckDelegatedTo();}
inline CkDelegateData *ckDelegatedPtr(void) const {return CProxyElement_CkArrayMap::ckDelegatedPtr();}
CkGroupID ckDelegatedIdx(void) const {return CProxyElement_CkArrayMap::ckDelegatedIdx();}
inline void ckCheck(void) const {CProxyElement_CkArrayMap::ckCheck();}
CkChareID ckGetChareID(void) const
   {return CProxyElement_CkArrayMap::ckGetChareID();}
CkGroupID ckGetGroupID(void) const
   {return CProxyElement_CkArrayMap::ckGetGroupID();}
operator CkGroupID () const { return ckGetGroupID(); }
inline void setReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxyElement_CkArrayMap::setReductionClient(fn,param); }
inline void ckSetReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxyElement_CkArrayMap::ckSetReductionClient(fn,param); }
inline void ckSetReductionClient(CkCallback *cb) const
{ CProxyElement_CkArrayMap::ckSetReductionClient(cb); }
int ckGetGroupPe(void) const
{return CProxyElement_CkArrayMap::ckGetGroupPe();}
    void ckDelegate(CkDelegateMgr *dTo,CkDelegateData *dPtr=NULL) {
      CProxyElement_CkArrayMap::ckDelegate(dTo,dPtr);
    }
    void ckUndelegate(void) {
      CProxyElement_CkArrayMap::ckUndelegate();
    }
    void pup(PUP::er &p) {
      CProxyElement_CkArrayMap::pup(p);
    }
    void ckSetGroupID(CkGroupID g) {
      CProxyElement_CkArrayMap::ckSetGroupID(g);
    }
    BlockCyclicMap* ckLocalBranch(void) const {
      return ckLocalBranch(ckGetGroupID());
    }
    static BlockCyclicMap* ckLocalBranch(CkGroupID gID) {
      return (BlockCyclicMap*)CkLocalBranch(gID);
    }
/* DECLS: BlockCyclicMap(void);
 */

};
PUPmarshall(CProxyElement_BlockCyclicMap)
/* ---------------- collective proxy -------------- */
class CProxy_BlockCyclicMap: public CProxy_CkArrayMap{
  public:
    typedef BlockCyclicMap local_t;
    typedef CkIndex_BlockCyclicMap index_t;
    typedef CProxy_BlockCyclicMap proxy_t;
    typedef CProxyElement_BlockCyclicMap element_t;
    typedef CProxySection_BlockCyclicMap section_t;

    CProxy_BlockCyclicMap(void) {}
    CProxy_BlockCyclicMap(const IrrGroup *g) : CProxy_CkArrayMap(g){  }
    CProxy_BlockCyclicMap(CkGroupID _gid,CK_DELCTOR_PARAM) : CProxy_CkArrayMap(_gid,CK_DELCTOR_ARGS){  }
    CProxy_BlockCyclicMap(CkGroupID _gid) : CProxy_CkArrayMap(_gid){  }
    CProxyElement_BlockCyclicMap operator[](int onPE) const
      {return CProxyElement_BlockCyclicMap(ckGetGroupID(),onPE,CK_DELCTOR_CALL);}
int ckIsDelegated(void) const {return CProxy_CkArrayMap::ckIsDelegated();}
inline CkDelegateMgr *ckDelegatedTo(void) const {return CProxy_CkArrayMap::ckDelegatedTo();}
inline CkDelegateData *ckDelegatedPtr(void) const {return CProxy_CkArrayMap::ckDelegatedPtr();}
CkGroupID ckDelegatedIdx(void) const {return CProxy_CkArrayMap::ckDelegatedIdx();}
inline void ckCheck(void) const {CProxy_CkArrayMap::ckCheck();}
CkChareID ckGetChareID(void) const
   {return CProxy_CkArrayMap::ckGetChareID();}
CkGroupID ckGetGroupID(void) const
   {return CProxy_CkArrayMap::ckGetGroupID();}
operator CkGroupID () const { return ckGetGroupID(); }
inline void setReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxy_CkArrayMap::setReductionClient(fn,param); }
inline void ckSetReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxy_CkArrayMap::ckSetReductionClient(fn,param); }
inline void ckSetReductionClient(CkCallback *cb) const
{ CProxy_CkArrayMap::ckSetReductionClient(cb); }
    void ckDelegate(CkDelegateMgr *dTo,CkDelegateData *dPtr=NULL) {
      CProxy_CkArrayMap::ckDelegate(dTo,dPtr);
    }
    void ckUndelegate(void) {
      CProxy_CkArrayMap::ckUndelegate();
    }
    void pup(PUP::er &p) {
      CProxy_CkArrayMap::pup(p);
    }
    void ckSetGroupID(CkGroupID g) {
      CProxy_CkArrayMap::ckSetGroupID(g);
    }
    BlockCyclicMap* ckLocalBranch(void) const {
      return ckLocalBranch(ckGetGroupID());
    }
    static BlockCyclicMap* ckLocalBranch(CkGroupID gID) {
      return (BlockCyclicMap*)CkLocalBranch(gID);
    }
/* DECLS: BlockCyclicMap(void);
 */
    static CkGroupID ckNew(void);

};
PUPmarshall(CProxy_BlockCyclicMap)
/* ---------------- section proxy -------------- */
class CProxySection_BlockCyclicMap: public CProxySection_CkArrayMap{
  public:
    typedef BlockCyclicMap local_t;
    typedef CkIndex_BlockCyclicMap index_t;
    typedef CProxy_BlockCyclicMap proxy_t;
    typedef CProxyElement_BlockCyclicMap element_t;
    typedef CProxySection_BlockCyclicMap section_t;

    CProxySection_BlockCyclicMap(void) {}
    CProxySection_BlockCyclicMap(const IrrGroup *g) : CProxySection_CkArrayMap(g){  }
    CProxySection_BlockCyclicMap(const CkGroupID &_gid,const int *_pelist,int _npes,CK_DELCTOR_PARAM) : CProxySection_CkArrayMap(_gid,_pelist,_npes,CK_DELCTOR_ARGS){  }
    CProxySection_BlockCyclicMap(const CkGroupID &_gid,const int *_pelist,int _npes) : CProxySection_CkArrayMap(_gid,_pelist,_npes){  }
    CProxySection_BlockCyclicMap(int n,const CkGroupID *_gid, int const * const *_pelist,const int *_npes) : CProxySection_CkArrayMap(n,_gid,_pelist,_npes){  }
    CProxySection_BlockCyclicMap(int n,const CkGroupID *_gid, int const * const *_pelist,const int *_npes,CK_DELCTOR_PARAM) : CProxySection_CkArrayMap(n,_gid,_pelist,_npes,CK_DELCTOR_ARGS){  }
int ckIsDelegated(void) const {return CProxySection_CkArrayMap::ckIsDelegated();}
inline CkDelegateMgr *ckDelegatedTo(void) const {return CProxySection_CkArrayMap::ckDelegatedTo();}
inline CkDelegateData *ckDelegatedPtr(void) const {return CProxySection_CkArrayMap::ckDelegatedPtr();}
CkGroupID ckDelegatedIdx(void) const {return CProxySection_CkArrayMap::ckDelegatedIdx();}
inline void ckCheck(void) const {CProxySection_CkArrayMap::ckCheck();}
CkChareID ckGetChareID(void) const
   {return CProxySection_CkArrayMap::ckGetChareID();}
CkGroupID ckGetGroupID(void) const
   {return CProxySection_CkArrayMap::ckGetGroupID();}
operator CkGroupID () const { return ckGetGroupID(); }
inline void setReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxySection_CkArrayMap::setReductionClient(fn,param); }
inline void ckSetReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxySection_CkArrayMap::ckSetReductionClient(fn,param); }
inline void ckSetReductionClient(CkCallback *cb) const
{ CProxySection_CkArrayMap::ckSetReductionClient(cb); }
inline int ckGetNumSections() const
{ return CProxySection_CkArrayMap::ckGetNumSections(); }
inline CkSectionInfo &ckGetSectionInfo()
{ return CProxySection_CkArrayMap::ckGetSectionInfo(); }
inline CkSectionID *ckGetSectionIDs()
{ return CProxySection_CkArrayMap::ckGetSectionIDs(); }
inline CkSectionID &ckGetSectionID()
{ return CProxySection_CkArrayMap::ckGetSectionID(); }
inline CkSectionID &ckGetSectionID(int i)
{ return CProxySection_CkArrayMap::ckGetSectionID(i); }
inline CkGroupID ckGetGroupIDn(int i) const
{ return CProxySection_CkArrayMap::ckGetGroupIDn(i); }
inline int *ckGetElements() const
{ return CProxySection_CkArrayMap::ckGetElements(); }
inline int *ckGetElements(int i) const
{ return CProxySection_CkArrayMap::ckGetElements(i); }
inline int ckGetNumElements() const
{ return CProxySection_CkArrayMap::ckGetNumElements(); } 
inline int ckGetNumElements(int i) const
{ return CProxySection_CkArrayMap::ckGetNumElements(i); }
    void ckDelegate(CkDelegateMgr *dTo,CkDelegateData *dPtr=NULL) {
      CProxySection_CkArrayMap::ckDelegate(dTo,dPtr);
    }
    void ckUndelegate(void) {
      CProxySection_CkArrayMap::ckUndelegate();
    }
    void pup(PUP::er &p) {
      CProxySection_CkArrayMap::pup(p);
    }
    void ckSetGroupID(CkGroupID g) {
      CProxySection_CkArrayMap::ckSetGroupID(g);
    }
    BlockCyclicMap* ckLocalBranch(void) const {
      return ckLocalBranch(ckGetGroupID());
    }
    static BlockCyclicMap* ckLocalBranch(CkGroupID gID) {
      return (BlockCyclicMap*)CkLocalBranch(gID);
    }
/* DECLS: BlockCyclicMap(void);
 */

};
PUPmarshall(CProxySection_BlockCyclicMap)
typedef CBaseT1<CkArrayMap, CProxy_BlockCyclicMap> CBase_BlockCyclicMap;

/* DECLS: group RealBlockCyclicMap: CkArrayMap{
RealBlockCyclicMap(int r, int num_blocks);
};
 */
 class RealBlockCyclicMap;
 class CkIndex_RealBlockCyclicMap;
 class CProxy_RealBlockCyclicMap;
 class CProxyElement_RealBlockCyclicMap;
 class CProxySection_RealBlockCyclicMap;
/* --------------- index object ------------------ */
class CkIndex_RealBlockCyclicMap:public CProxyElement_CkArrayMap{
  public:
    typedef RealBlockCyclicMap local_t;
    typedef CkIndex_RealBlockCyclicMap index_t;
    typedef CProxy_RealBlockCyclicMap proxy_t;
    typedef CProxyElement_RealBlockCyclicMap element_t;
    typedef CProxySection_RealBlockCyclicMap section_t;

    static int __idx;
    static void __register(const char *s, size_t size);
/* DECLS: RealBlockCyclicMap(int r, int num_blocks);
 */
    static int __idx_RealBlockCyclicMap_marshall1;
    static int ckNew(int r, int num_blocks) { return __idx_RealBlockCyclicMap_marshall1; }
    static void _call_RealBlockCyclicMap_marshall1(void* impl_msg,RealBlockCyclicMap* impl_obj);
    static int _callmarshall_RealBlockCyclicMap_marshall1(char* impl_buf,RealBlockCyclicMap* impl_obj);
    static void _marshallmessagepup_RealBlockCyclicMap_marshall1(PUP::er &p,void *msg);

};
/* --------------- element proxy ------------------ */
class CProxyElement_RealBlockCyclicMap: public CProxyElement_CkArrayMap{
  public:
    typedef RealBlockCyclicMap local_t;
    typedef CkIndex_RealBlockCyclicMap index_t;
    typedef CProxy_RealBlockCyclicMap proxy_t;
    typedef CProxyElement_RealBlockCyclicMap element_t;
    typedef CProxySection_RealBlockCyclicMap section_t;

    CProxyElement_RealBlockCyclicMap(void) {}
    CProxyElement_RealBlockCyclicMap(const IrrGroup *g) : CProxyElement_CkArrayMap(g){  }
    CProxyElement_RealBlockCyclicMap(CkGroupID _gid,int _onPE,CK_DELCTOR_PARAM) : CProxyElement_CkArrayMap(_gid,_onPE,CK_DELCTOR_ARGS){  }
    CProxyElement_RealBlockCyclicMap(CkGroupID _gid,int _onPE) : CProxyElement_CkArrayMap(_gid,_onPE){  }
int ckIsDelegated(void) const {return CProxyElement_CkArrayMap::ckIsDelegated();}
inline CkDelegateMgr *ckDelegatedTo(void) const {return CProxyElement_CkArrayMap::ckDelegatedTo();}
inline CkDelegateData *ckDelegatedPtr(void) const {return CProxyElement_CkArrayMap::ckDelegatedPtr();}
CkGroupID ckDelegatedIdx(void) const {return CProxyElement_CkArrayMap::ckDelegatedIdx();}
inline void ckCheck(void) const {CProxyElement_CkArrayMap::ckCheck();}
CkChareID ckGetChareID(void) const
   {return CProxyElement_CkArrayMap::ckGetChareID();}
CkGroupID ckGetGroupID(void) const
   {return CProxyElement_CkArrayMap::ckGetGroupID();}
operator CkGroupID () const { return ckGetGroupID(); }
inline void setReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxyElement_CkArrayMap::setReductionClient(fn,param); }
inline void ckSetReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxyElement_CkArrayMap::ckSetReductionClient(fn,param); }
inline void ckSetReductionClient(CkCallback *cb) const
{ CProxyElement_CkArrayMap::ckSetReductionClient(cb); }
int ckGetGroupPe(void) const
{return CProxyElement_CkArrayMap::ckGetGroupPe();}
    void ckDelegate(CkDelegateMgr *dTo,CkDelegateData *dPtr=NULL) {
      CProxyElement_CkArrayMap::ckDelegate(dTo,dPtr);
    }
    void ckUndelegate(void) {
      CProxyElement_CkArrayMap::ckUndelegate();
    }
    void pup(PUP::er &p) {
      CProxyElement_CkArrayMap::pup(p);
    }
    void ckSetGroupID(CkGroupID g) {
      CProxyElement_CkArrayMap::ckSetGroupID(g);
    }
    RealBlockCyclicMap* ckLocalBranch(void) const {
      return ckLocalBranch(ckGetGroupID());
    }
    static RealBlockCyclicMap* ckLocalBranch(CkGroupID gID) {
      return (RealBlockCyclicMap*)CkLocalBranch(gID);
    }
/* DECLS: RealBlockCyclicMap(int r, int num_blocks);
 */

};
PUPmarshall(CProxyElement_RealBlockCyclicMap)
/* ---------------- collective proxy -------------- */
class CProxy_RealBlockCyclicMap: public CProxy_CkArrayMap{
  public:
    typedef RealBlockCyclicMap local_t;
    typedef CkIndex_RealBlockCyclicMap index_t;
    typedef CProxy_RealBlockCyclicMap proxy_t;
    typedef CProxyElement_RealBlockCyclicMap element_t;
    typedef CProxySection_RealBlockCyclicMap section_t;

    CProxy_RealBlockCyclicMap(void) {}
    CProxy_RealBlockCyclicMap(const IrrGroup *g) : CProxy_CkArrayMap(g){  }
    CProxy_RealBlockCyclicMap(CkGroupID _gid,CK_DELCTOR_PARAM) : CProxy_CkArrayMap(_gid,CK_DELCTOR_ARGS){  }
    CProxy_RealBlockCyclicMap(CkGroupID _gid) : CProxy_CkArrayMap(_gid){  }
    CProxyElement_RealBlockCyclicMap operator[](int onPE) const
      {return CProxyElement_RealBlockCyclicMap(ckGetGroupID(),onPE,CK_DELCTOR_CALL);}
int ckIsDelegated(void) const {return CProxy_CkArrayMap::ckIsDelegated();}
inline CkDelegateMgr *ckDelegatedTo(void) const {return CProxy_CkArrayMap::ckDelegatedTo();}
inline CkDelegateData *ckDelegatedPtr(void) const {return CProxy_CkArrayMap::ckDelegatedPtr();}
CkGroupID ckDelegatedIdx(void) const {return CProxy_CkArrayMap::ckDelegatedIdx();}
inline void ckCheck(void) const {CProxy_CkArrayMap::ckCheck();}
CkChareID ckGetChareID(void) const
   {return CProxy_CkArrayMap::ckGetChareID();}
CkGroupID ckGetGroupID(void) const
   {return CProxy_CkArrayMap::ckGetGroupID();}
operator CkGroupID () const { return ckGetGroupID(); }
inline void setReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxy_CkArrayMap::setReductionClient(fn,param); }
inline void ckSetReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxy_CkArrayMap::ckSetReductionClient(fn,param); }
inline void ckSetReductionClient(CkCallback *cb) const
{ CProxy_CkArrayMap::ckSetReductionClient(cb); }
    void ckDelegate(CkDelegateMgr *dTo,CkDelegateData *dPtr=NULL) {
      CProxy_CkArrayMap::ckDelegate(dTo,dPtr);
    }
    void ckUndelegate(void) {
      CProxy_CkArrayMap::ckUndelegate();
    }
    void pup(PUP::er &p) {
      CProxy_CkArrayMap::pup(p);
    }
    void ckSetGroupID(CkGroupID g) {
      CProxy_CkArrayMap::ckSetGroupID(g);
    }
    RealBlockCyclicMap* ckLocalBranch(void) const {
      return ckLocalBranch(ckGetGroupID());
    }
    static RealBlockCyclicMap* ckLocalBranch(CkGroupID gID) {
      return (RealBlockCyclicMap*)CkLocalBranch(gID);
    }
/* DECLS: RealBlockCyclicMap(int r, int num_blocks);
 */
    static CkGroupID ckNew(int r, int num_blocks, const CkEntryOptions *impl_e_opts=NULL);
    CProxy_RealBlockCyclicMap(int r, int num_blocks, const CkEntryOptions *impl_e_opts=NULL);

};
PUPmarshall(CProxy_RealBlockCyclicMap)
/* ---------------- section proxy -------------- */
class CProxySection_RealBlockCyclicMap: public CProxySection_CkArrayMap{
  public:
    typedef RealBlockCyclicMap local_t;
    typedef CkIndex_RealBlockCyclicMap index_t;
    typedef CProxy_RealBlockCyclicMap proxy_t;
    typedef CProxyElement_RealBlockCyclicMap element_t;
    typedef CProxySection_RealBlockCyclicMap section_t;

    CProxySection_RealBlockCyclicMap(void) {}
    CProxySection_RealBlockCyclicMap(const IrrGroup *g) : CProxySection_CkArrayMap(g){  }
    CProxySection_RealBlockCyclicMap(const CkGroupID &_gid,const int *_pelist,int _npes,CK_DELCTOR_PARAM) : CProxySection_CkArrayMap(_gid,_pelist,_npes,CK_DELCTOR_ARGS){  }
    CProxySection_RealBlockCyclicMap(const CkGroupID &_gid,const int *_pelist,int _npes) : CProxySection_CkArrayMap(_gid,_pelist,_npes){  }
    CProxySection_RealBlockCyclicMap(int n,const CkGroupID *_gid, int const * const *_pelist,const int *_npes) : CProxySection_CkArrayMap(n,_gid,_pelist,_npes){  }
    CProxySection_RealBlockCyclicMap(int n,const CkGroupID *_gid, int const * const *_pelist,const int *_npes,CK_DELCTOR_PARAM) : CProxySection_CkArrayMap(n,_gid,_pelist,_npes,CK_DELCTOR_ARGS){  }
int ckIsDelegated(void) const {return CProxySection_CkArrayMap::ckIsDelegated();}
inline CkDelegateMgr *ckDelegatedTo(void) const {return CProxySection_CkArrayMap::ckDelegatedTo();}
inline CkDelegateData *ckDelegatedPtr(void) const {return CProxySection_CkArrayMap::ckDelegatedPtr();}
CkGroupID ckDelegatedIdx(void) const {return CProxySection_CkArrayMap::ckDelegatedIdx();}
inline void ckCheck(void) const {CProxySection_CkArrayMap::ckCheck();}
CkChareID ckGetChareID(void) const
   {return CProxySection_CkArrayMap::ckGetChareID();}
CkGroupID ckGetGroupID(void) const
   {return CProxySection_CkArrayMap::ckGetGroupID();}
operator CkGroupID () const { return ckGetGroupID(); }
inline void setReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxySection_CkArrayMap::setReductionClient(fn,param); }
inline void ckSetReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxySection_CkArrayMap::ckSetReductionClient(fn,param); }
inline void ckSetReductionClient(CkCallback *cb) const
{ CProxySection_CkArrayMap::ckSetReductionClient(cb); }
inline int ckGetNumSections() const
{ return CProxySection_CkArrayMap::ckGetNumSections(); }
inline CkSectionInfo &ckGetSectionInfo()
{ return CProxySection_CkArrayMap::ckGetSectionInfo(); }
inline CkSectionID *ckGetSectionIDs()
{ return CProxySection_CkArrayMap::ckGetSectionIDs(); }
inline CkSectionID &ckGetSectionID()
{ return CProxySection_CkArrayMap::ckGetSectionID(); }
inline CkSectionID &ckGetSectionID(int i)
{ return CProxySection_CkArrayMap::ckGetSectionID(i); }
inline CkGroupID ckGetGroupIDn(int i) const
{ return CProxySection_CkArrayMap::ckGetGroupIDn(i); }
inline int *ckGetElements() const
{ return CProxySection_CkArrayMap::ckGetElements(); }
inline int *ckGetElements(int i) const
{ return CProxySection_CkArrayMap::ckGetElements(i); }
inline int ckGetNumElements() const
{ return CProxySection_CkArrayMap::ckGetNumElements(); } 
inline int ckGetNumElements(int i) const
{ return CProxySection_CkArrayMap::ckGetNumElements(i); }
    void ckDelegate(CkDelegateMgr *dTo,CkDelegateData *dPtr=NULL) {
      CProxySection_CkArrayMap::ckDelegate(dTo,dPtr);
    }
    void ckUndelegate(void) {
      CProxySection_CkArrayMap::ckUndelegate();
    }
    void pup(PUP::er &p) {
      CProxySection_CkArrayMap::pup(p);
    }
    void ckSetGroupID(CkGroupID g) {
      CProxySection_CkArrayMap::ckSetGroupID(g);
    }
    RealBlockCyclicMap* ckLocalBranch(void) const {
      return ckLocalBranch(ckGetGroupID());
    }
    static RealBlockCyclicMap* ckLocalBranch(CkGroupID gID) {
      return (RealBlockCyclicMap*)CkLocalBranch(gID);
    }
/* DECLS: RealBlockCyclicMap(int r, int num_blocks);
 */

};
PUPmarshall(CProxySection_RealBlockCyclicMap)
typedef CBaseT1<CkArrayMap, CProxy_RealBlockCyclicMap> CBase_RealBlockCyclicMap;

/* DECLS: group LUSnakeMap: CkArrayMap{
LUSnakeMap(int impl_noname_2, int impl_noname_3);
};
 */
 class LUSnakeMap;
 class CkIndex_LUSnakeMap;
 class CProxy_LUSnakeMap;
 class CProxyElement_LUSnakeMap;
 class CProxySection_LUSnakeMap;
/* --------------- index object ------------------ */
class CkIndex_LUSnakeMap:public CProxyElement_CkArrayMap{
  public:
    typedef LUSnakeMap local_t;
    typedef CkIndex_LUSnakeMap index_t;
    typedef CProxy_LUSnakeMap proxy_t;
    typedef CProxyElement_LUSnakeMap element_t;
    typedef CProxySection_LUSnakeMap section_t;

    static int __idx;
    static void __register(const char *s, size_t size);
/* DECLS: LUSnakeMap(int impl_noname_2, int impl_noname_3);
 */
    static int __idx_LUSnakeMap_marshall1;
    static int ckNew(int impl_noname_2, int impl_noname_3) { return __idx_LUSnakeMap_marshall1; }
    static void _call_LUSnakeMap_marshall1(void* impl_msg,LUSnakeMap* impl_obj);
    static int _callmarshall_LUSnakeMap_marshall1(char* impl_buf,LUSnakeMap* impl_obj);
    static void _marshallmessagepup_LUSnakeMap_marshall1(PUP::er &p,void *msg);

};
/* --------------- element proxy ------------------ */
class CProxyElement_LUSnakeMap: public CProxyElement_CkArrayMap{
  public:
    typedef LUSnakeMap local_t;
    typedef CkIndex_LUSnakeMap index_t;
    typedef CProxy_LUSnakeMap proxy_t;
    typedef CProxyElement_LUSnakeMap element_t;
    typedef CProxySection_LUSnakeMap section_t;

    CProxyElement_LUSnakeMap(void) {}
    CProxyElement_LUSnakeMap(const IrrGroup *g) : CProxyElement_CkArrayMap(g){  }
    CProxyElement_LUSnakeMap(CkGroupID _gid,int _onPE,CK_DELCTOR_PARAM) : CProxyElement_CkArrayMap(_gid,_onPE,CK_DELCTOR_ARGS){  }
    CProxyElement_LUSnakeMap(CkGroupID _gid,int _onPE) : CProxyElement_CkArrayMap(_gid,_onPE){  }
int ckIsDelegated(void) const {return CProxyElement_CkArrayMap::ckIsDelegated();}
inline CkDelegateMgr *ckDelegatedTo(void) const {return CProxyElement_CkArrayMap::ckDelegatedTo();}
inline CkDelegateData *ckDelegatedPtr(void) const {return CProxyElement_CkArrayMap::ckDelegatedPtr();}
CkGroupID ckDelegatedIdx(void) const {return CProxyElement_CkArrayMap::ckDelegatedIdx();}
inline void ckCheck(void) const {CProxyElement_CkArrayMap::ckCheck();}
CkChareID ckGetChareID(void) const
   {return CProxyElement_CkArrayMap::ckGetChareID();}
CkGroupID ckGetGroupID(void) const
   {return CProxyElement_CkArrayMap::ckGetGroupID();}
operator CkGroupID () const { return ckGetGroupID(); }
inline void setReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxyElement_CkArrayMap::setReductionClient(fn,param); }
inline void ckSetReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxyElement_CkArrayMap::ckSetReductionClient(fn,param); }
inline void ckSetReductionClient(CkCallback *cb) const
{ CProxyElement_CkArrayMap::ckSetReductionClient(cb); }
int ckGetGroupPe(void) const
{return CProxyElement_CkArrayMap::ckGetGroupPe();}
    void ckDelegate(CkDelegateMgr *dTo,CkDelegateData *dPtr=NULL) {
      CProxyElement_CkArrayMap::ckDelegate(dTo,dPtr);
    }
    void ckUndelegate(void) {
      CProxyElement_CkArrayMap::ckUndelegate();
    }
    void pup(PUP::er &p) {
      CProxyElement_CkArrayMap::pup(p);
    }
    void ckSetGroupID(CkGroupID g) {
      CProxyElement_CkArrayMap::ckSetGroupID(g);
    }
    LUSnakeMap* ckLocalBranch(void) const {
      return ckLocalBranch(ckGetGroupID());
    }
    static LUSnakeMap* ckLocalBranch(CkGroupID gID) {
      return (LUSnakeMap*)CkLocalBranch(gID);
    }
/* DECLS: LUSnakeMap(int impl_noname_2, int impl_noname_3);
 */

};
PUPmarshall(CProxyElement_LUSnakeMap)
/* ---------------- collective proxy -------------- */
class CProxy_LUSnakeMap: public CProxy_CkArrayMap{
  public:
    typedef LUSnakeMap local_t;
    typedef CkIndex_LUSnakeMap index_t;
    typedef CProxy_LUSnakeMap proxy_t;
    typedef CProxyElement_LUSnakeMap element_t;
    typedef CProxySection_LUSnakeMap section_t;

    CProxy_LUSnakeMap(void) {}
    CProxy_LUSnakeMap(const IrrGroup *g) : CProxy_CkArrayMap(g){  }
    CProxy_LUSnakeMap(CkGroupID _gid,CK_DELCTOR_PARAM) : CProxy_CkArrayMap(_gid,CK_DELCTOR_ARGS){  }
    CProxy_LUSnakeMap(CkGroupID _gid) : CProxy_CkArrayMap(_gid){  }
    CProxyElement_LUSnakeMap operator[](int onPE) const
      {return CProxyElement_LUSnakeMap(ckGetGroupID(),onPE,CK_DELCTOR_CALL);}
int ckIsDelegated(void) const {return CProxy_CkArrayMap::ckIsDelegated();}
inline CkDelegateMgr *ckDelegatedTo(void) const {return CProxy_CkArrayMap::ckDelegatedTo();}
inline CkDelegateData *ckDelegatedPtr(void) const {return CProxy_CkArrayMap::ckDelegatedPtr();}
CkGroupID ckDelegatedIdx(void) const {return CProxy_CkArrayMap::ckDelegatedIdx();}
inline void ckCheck(void) const {CProxy_CkArrayMap::ckCheck();}
CkChareID ckGetChareID(void) const
   {return CProxy_CkArrayMap::ckGetChareID();}
CkGroupID ckGetGroupID(void) const
   {return CProxy_CkArrayMap::ckGetGroupID();}
operator CkGroupID () const { return ckGetGroupID(); }
inline void setReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxy_CkArrayMap::setReductionClient(fn,param); }
inline void ckSetReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxy_CkArrayMap::ckSetReductionClient(fn,param); }
inline void ckSetReductionClient(CkCallback *cb) const
{ CProxy_CkArrayMap::ckSetReductionClient(cb); }
    void ckDelegate(CkDelegateMgr *dTo,CkDelegateData *dPtr=NULL) {
      CProxy_CkArrayMap::ckDelegate(dTo,dPtr);
    }
    void ckUndelegate(void) {
      CProxy_CkArrayMap::ckUndelegate();
    }
    void pup(PUP::er &p) {
      CProxy_CkArrayMap::pup(p);
    }
    void ckSetGroupID(CkGroupID g) {
      CProxy_CkArrayMap::ckSetGroupID(g);
    }
    LUSnakeMap* ckLocalBranch(void) const {
      return ckLocalBranch(ckGetGroupID());
    }
    static LUSnakeMap* ckLocalBranch(CkGroupID gID) {
      return (LUSnakeMap*)CkLocalBranch(gID);
    }
/* DECLS: LUSnakeMap(int impl_noname_2, int impl_noname_3);
 */
    static CkGroupID ckNew(int impl_noname_2, int impl_noname_3, const CkEntryOptions *impl_e_opts=NULL);
    CProxy_LUSnakeMap(int impl_noname_2, int impl_noname_3, const CkEntryOptions *impl_e_opts=NULL);

};
PUPmarshall(CProxy_LUSnakeMap)
/* ---------------- section proxy -------------- */
class CProxySection_LUSnakeMap: public CProxySection_CkArrayMap{
  public:
    typedef LUSnakeMap local_t;
    typedef CkIndex_LUSnakeMap index_t;
    typedef CProxy_LUSnakeMap proxy_t;
    typedef CProxyElement_LUSnakeMap element_t;
    typedef CProxySection_LUSnakeMap section_t;

    CProxySection_LUSnakeMap(void) {}
    CProxySection_LUSnakeMap(const IrrGroup *g) : CProxySection_CkArrayMap(g){  }
    CProxySection_LUSnakeMap(const CkGroupID &_gid,const int *_pelist,int _npes,CK_DELCTOR_PARAM) : CProxySection_CkArrayMap(_gid,_pelist,_npes,CK_DELCTOR_ARGS){  }
    CProxySection_LUSnakeMap(const CkGroupID &_gid,const int *_pelist,int _npes) : CProxySection_CkArrayMap(_gid,_pelist,_npes){  }
    CProxySection_LUSnakeMap(int n,const CkGroupID *_gid, int const * const *_pelist,const int *_npes) : CProxySection_CkArrayMap(n,_gid,_pelist,_npes){  }
    CProxySection_LUSnakeMap(int n,const CkGroupID *_gid, int const * const *_pelist,const int *_npes,CK_DELCTOR_PARAM) : CProxySection_CkArrayMap(n,_gid,_pelist,_npes,CK_DELCTOR_ARGS){  }
int ckIsDelegated(void) const {return CProxySection_CkArrayMap::ckIsDelegated();}
inline CkDelegateMgr *ckDelegatedTo(void) const {return CProxySection_CkArrayMap::ckDelegatedTo();}
inline CkDelegateData *ckDelegatedPtr(void) const {return CProxySection_CkArrayMap::ckDelegatedPtr();}
CkGroupID ckDelegatedIdx(void) const {return CProxySection_CkArrayMap::ckDelegatedIdx();}
inline void ckCheck(void) const {CProxySection_CkArrayMap::ckCheck();}
CkChareID ckGetChareID(void) const
   {return CProxySection_CkArrayMap::ckGetChareID();}
CkGroupID ckGetGroupID(void) const
   {return CProxySection_CkArrayMap::ckGetGroupID();}
operator CkGroupID () const { return ckGetGroupID(); }
inline void setReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxySection_CkArrayMap::setReductionClient(fn,param); }
inline void ckSetReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxySection_CkArrayMap::ckSetReductionClient(fn,param); }
inline void ckSetReductionClient(CkCallback *cb) const
{ CProxySection_CkArrayMap::ckSetReductionClient(cb); }
inline int ckGetNumSections() const
{ return CProxySection_CkArrayMap::ckGetNumSections(); }
inline CkSectionInfo &ckGetSectionInfo()
{ return CProxySection_CkArrayMap::ckGetSectionInfo(); }
inline CkSectionID *ckGetSectionIDs()
{ return CProxySection_CkArrayMap::ckGetSectionIDs(); }
inline CkSectionID &ckGetSectionID()
{ return CProxySection_CkArrayMap::ckGetSectionID(); }
inline CkSectionID &ckGetSectionID(int i)
{ return CProxySection_CkArrayMap::ckGetSectionID(i); }
inline CkGroupID ckGetGroupIDn(int i) const
{ return CProxySection_CkArrayMap::ckGetGroupIDn(i); }
inline int *ckGetElements() const
{ return CProxySection_CkArrayMap::ckGetElements(); }
inline int *ckGetElements(int i) const
{ return CProxySection_CkArrayMap::ckGetElements(i); }
inline int ckGetNumElements() const
{ return CProxySection_CkArrayMap::ckGetNumElements(); } 
inline int ckGetNumElements(int i) const
{ return CProxySection_CkArrayMap::ckGetNumElements(i); }
    void ckDelegate(CkDelegateMgr *dTo,CkDelegateData *dPtr=NULL) {
      CProxySection_CkArrayMap::ckDelegate(dTo,dPtr);
    }
    void ckUndelegate(void) {
      CProxySection_CkArrayMap::ckUndelegate();
    }
    void pup(PUP::er &p) {
      CProxySection_CkArrayMap::pup(p);
    }
    void ckSetGroupID(CkGroupID g) {
      CProxySection_CkArrayMap::ckSetGroupID(g);
    }
    LUSnakeMap* ckLocalBranch(void) const {
      return ckLocalBranch(ckGetGroupID());
    }
    static LUSnakeMap* ckLocalBranch(CkGroupID gID) {
      return (LUSnakeMap*)CkLocalBranch(gID);
    }
/* DECLS: LUSnakeMap(int impl_noname_2, int impl_noname_3);
 */

};
PUPmarshall(CProxySection_LUSnakeMap)
typedef CBaseT1<CkArrayMap, CProxy_LUSnakeMap> CBase_LUSnakeMap;

/* DECLS: group LUBalancedSnakeMap: CkArrayMap{
LUBalancedSnakeMap(int impl_noname_4, int impl_noname_5);
};
 */
 class LUBalancedSnakeMap;
 class CkIndex_LUBalancedSnakeMap;
 class CProxy_LUBalancedSnakeMap;
 class CProxyElement_LUBalancedSnakeMap;
 class CProxySection_LUBalancedSnakeMap;
/* --------------- index object ------------------ */
class CkIndex_LUBalancedSnakeMap:public CProxyElement_CkArrayMap{
  public:
    typedef LUBalancedSnakeMap local_t;
    typedef CkIndex_LUBalancedSnakeMap index_t;
    typedef CProxy_LUBalancedSnakeMap proxy_t;
    typedef CProxyElement_LUBalancedSnakeMap element_t;
    typedef CProxySection_LUBalancedSnakeMap section_t;

    static int __idx;
    static void __register(const char *s, size_t size);
/* DECLS: LUBalancedSnakeMap(int impl_noname_4, int impl_noname_5);
 */
    static int __idx_LUBalancedSnakeMap_marshall1;
    static int ckNew(int impl_noname_4, int impl_noname_5) { return __idx_LUBalancedSnakeMap_marshall1; }
    static void _call_LUBalancedSnakeMap_marshall1(void* impl_msg,LUBalancedSnakeMap* impl_obj);
    static int _callmarshall_LUBalancedSnakeMap_marshall1(char* impl_buf,LUBalancedSnakeMap* impl_obj);
    static void _marshallmessagepup_LUBalancedSnakeMap_marshall1(PUP::er &p,void *msg);

};
/* --------------- element proxy ------------------ */
class CProxyElement_LUBalancedSnakeMap: public CProxyElement_CkArrayMap{
  public:
    typedef LUBalancedSnakeMap local_t;
    typedef CkIndex_LUBalancedSnakeMap index_t;
    typedef CProxy_LUBalancedSnakeMap proxy_t;
    typedef CProxyElement_LUBalancedSnakeMap element_t;
    typedef CProxySection_LUBalancedSnakeMap section_t;

    CProxyElement_LUBalancedSnakeMap(void) {}
    CProxyElement_LUBalancedSnakeMap(const IrrGroup *g) : CProxyElement_CkArrayMap(g){  }
    CProxyElement_LUBalancedSnakeMap(CkGroupID _gid,int _onPE,CK_DELCTOR_PARAM) : CProxyElement_CkArrayMap(_gid,_onPE,CK_DELCTOR_ARGS){  }
    CProxyElement_LUBalancedSnakeMap(CkGroupID _gid,int _onPE) : CProxyElement_CkArrayMap(_gid,_onPE){  }
int ckIsDelegated(void) const {return CProxyElement_CkArrayMap::ckIsDelegated();}
inline CkDelegateMgr *ckDelegatedTo(void) const {return CProxyElement_CkArrayMap::ckDelegatedTo();}
inline CkDelegateData *ckDelegatedPtr(void) const {return CProxyElement_CkArrayMap::ckDelegatedPtr();}
CkGroupID ckDelegatedIdx(void) const {return CProxyElement_CkArrayMap::ckDelegatedIdx();}
inline void ckCheck(void) const {CProxyElement_CkArrayMap::ckCheck();}
CkChareID ckGetChareID(void) const
   {return CProxyElement_CkArrayMap::ckGetChareID();}
CkGroupID ckGetGroupID(void) const
   {return CProxyElement_CkArrayMap::ckGetGroupID();}
operator CkGroupID () const { return ckGetGroupID(); }
inline void setReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxyElement_CkArrayMap::setReductionClient(fn,param); }
inline void ckSetReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxyElement_CkArrayMap::ckSetReductionClient(fn,param); }
inline void ckSetReductionClient(CkCallback *cb) const
{ CProxyElement_CkArrayMap::ckSetReductionClient(cb); }
int ckGetGroupPe(void) const
{return CProxyElement_CkArrayMap::ckGetGroupPe();}
    void ckDelegate(CkDelegateMgr *dTo,CkDelegateData *dPtr=NULL) {
      CProxyElement_CkArrayMap::ckDelegate(dTo,dPtr);
    }
    void ckUndelegate(void) {
      CProxyElement_CkArrayMap::ckUndelegate();
    }
    void pup(PUP::er &p) {
      CProxyElement_CkArrayMap::pup(p);
    }
    void ckSetGroupID(CkGroupID g) {
      CProxyElement_CkArrayMap::ckSetGroupID(g);
    }
    LUBalancedSnakeMap* ckLocalBranch(void) const {
      return ckLocalBranch(ckGetGroupID());
    }
    static LUBalancedSnakeMap* ckLocalBranch(CkGroupID gID) {
      return (LUBalancedSnakeMap*)CkLocalBranch(gID);
    }
/* DECLS: LUBalancedSnakeMap(int impl_noname_4, int impl_noname_5);
 */

};
PUPmarshall(CProxyElement_LUBalancedSnakeMap)
/* ---------------- collective proxy -------------- */
class CProxy_LUBalancedSnakeMap: public CProxy_CkArrayMap{
  public:
    typedef LUBalancedSnakeMap local_t;
    typedef CkIndex_LUBalancedSnakeMap index_t;
    typedef CProxy_LUBalancedSnakeMap proxy_t;
    typedef CProxyElement_LUBalancedSnakeMap element_t;
    typedef CProxySection_LUBalancedSnakeMap section_t;

    CProxy_LUBalancedSnakeMap(void) {}
    CProxy_LUBalancedSnakeMap(const IrrGroup *g) : CProxy_CkArrayMap(g){  }
    CProxy_LUBalancedSnakeMap(CkGroupID _gid,CK_DELCTOR_PARAM) : CProxy_CkArrayMap(_gid,CK_DELCTOR_ARGS){  }
    CProxy_LUBalancedSnakeMap(CkGroupID _gid) : CProxy_CkArrayMap(_gid){  }
    CProxyElement_LUBalancedSnakeMap operator[](int onPE) const
      {return CProxyElement_LUBalancedSnakeMap(ckGetGroupID(),onPE,CK_DELCTOR_CALL);}
int ckIsDelegated(void) const {return CProxy_CkArrayMap::ckIsDelegated();}
inline CkDelegateMgr *ckDelegatedTo(void) const {return CProxy_CkArrayMap::ckDelegatedTo();}
inline CkDelegateData *ckDelegatedPtr(void) const {return CProxy_CkArrayMap::ckDelegatedPtr();}
CkGroupID ckDelegatedIdx(void) const {return CProxy_CkArrayMap::ckDelegatedIdx();}
inline void ckCheck(void) const {CProxy_CkArrayMap::ckCheck();}
CkChareID ckGetChareID(void) const
   {return CProxy_CkArrayMap::ckGetChareID();}
CkGroupID ckGetGroupID(void) const
   {return CProxy_CkArrayMap::ckGetGroupID();}
operator CkGroupID () const { return ckGetGroupID(); }
inline void setReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxy_CkArrayMap::setReductionClient(fn,param); }
inline void ckSetReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxy_CkArrayMap::ckSetReductionClient(fn,param); }
inline void ckSetReductionClient(CkCallback *cb) const
{ CProxy_CkArrayMap::ckSetReductionClient(cb); }
    void ckDelegate(CkDelegateMgr *dTo,CkDelegateData *dPtr=NULL) {
      CProxy_CkArrayMap::ckDelegate(dTo,dPtr);
    }
    void ckUndelegate(void) {
      CProxy_CkArrayMap::ckUndelegate();
    }
    void pup(PUP::er &p) {
      CProxy_CkArrayMap::pup(p);
    }
    void ckSetGroupID(CkGroupID g) {
      CProxy_CkArrayMap::ckSetGroupID(g);
    }
    LUBalancedSnakeMap* ckLocalBranch(void) const {
      return ckLocalBranch(ckGetGroupID());
    }
    static LUBalancedSnakeMap* ckLocalBranch(CkGroupID gID) {
      return (LUBalancedSnakeMap*)CkLocalBranch(gID);
    }
/* DECLS: LUBalancedSnakeMap(int impl_noname_4, int impl_noname_5);
 */
    static CkGroupID ckNew(int impl_noname_4, int impl_noname_5, const CkEntryOptions *impl_e_opts=NULL);
    CProxy_LUBalancedSnakeMap(int impl_noname_4, int impl_noname_5, const CkEntryOptions *impl_e_opts=NULL);

};
PUPmarshall(CProxy_LUBalancedSnakeMap)
/* ---------------- section proxy -------------- */
class CProxySection_LUBalancedSnakeMap: public CProxySection_CkArrayMap{
  public:
    typedef LUBalancedSnakeMap local_t;
    typedef CkIndex_LUBalancedSnakeMap index_t;
    typedef CProxy_LUBalancedSnakeMap proxy_t;
    typedef CProxyElement_LUBalancedSnakeMap element_t;
    typedef CProxySection_LUBalancedSnakeMap section_t;

    CProxySection_LUBalancedSnakeMap(void) {}
    CProxySection_LUBalancedSnakeMap(const IrrGroup *g) : CProxySection_CkArrayMap(g){  }
    CProxySection_LUBalancedSnakeMap(const CkGroupID &_gid,const int *_pelist,int _npes,CK_DELCTOR_PARAM) : CProxySection_CkArrayMap(_gid,_pelist,_npes,CK_DELCTOR_ARGS){  }
    CProxySection_LUBalancedSnakeMap(const CkGroupID &_gid,const int *_pelist,int _npes) : CProxySection_CkArrayMap(_gid,_pelist,_npes){  }
    CProxySection_LUBalancedSnakeMap(int n,const CkGroupID *_gid, int const * const *_pelist,const int *_npes) : CProxySection_CkArrayMap(n,_gid,_pelist,_npes){  }
    CProxySection_LUBalancedSnakeMap(int n,const CkGroupID *_gid, int const * const *_pelist,const int *_npes,CK_DELCTOR_PARAM) : CProxySection_CkArrayMap(n,_gid,_pelist,_npes,CK_DELCTOR_ARGS){  }
int ckIsDelegated(void) const {return CProxySection_CkArrayMap::ckIsDelegated();}
inline CkDelegateMgr *ckDelegatedTo(void) const {return CProxySection_CkArrayMap::ckDelegatedTo();}
inline CkDelegateData *ckDelegatedPtr(void) const {return CProxySection_CkArrayMap::ckDelegatedPtr();}
CkGroupID ckDelegatedIdx(void) const {return CProxySection_CkArrayMap::ckDelegatedIdx();}
inline void ckCheck(void) const {CProxySection_CkArrayMap::ckCheck();}
CkChareID ckGetChareID(void) const
   {return CProxySection_CkArrayMap::ckGetChareID();}
CkGroupID ckGetGroupID(void) const
   {return CProxySection_CkArrayMap::ckGetGroupID();}
operator CkGroupID () const { return ckGetGroupID(); }
inline void setReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxySection_CkArrayMap::setReductionClient(fn,param); }
inline void ckSetReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxySection_CkArrayMap::ckSetReductionClient(fn,param); }
inline void ckSetReductionClient(CkCallback *cb) const
{ CProxySection_CkArrayMap::ckSetReductionClient(cb); }
inline int ckGetNumSections() const
{ return CProxySection_CkArrayMap::ckGetNumSections(); }
inline CkSectionInfo &ckGetSectionInfo()
{ return CProxySection_CkArrayMap::ckGetSectionInfo(); }
inline CkSectionID *ckGetSectionIDs()
{ return CProxySection_CkArrayMap::ckGetSectionIDs(); }
inline CkSectionID &ckGetSectionID()
{ return CProxySection_CkArrayMap::ckGetSectionID(); }
inline CkSectionID &ckGetSectionID(int i)
{ return CProxySection_CkArrayMap::ckGetSectionID(i); }
inline CkGroupID ckGetGroupIDn(int i) const
{ return CProxySection_CkArrayMap::ckGetGroupIDn(i); }
inline int *ckGetElements() const
{ return CProxySection_CkArrayMap::ckGetElements(); }
inline int *ckGetElements(int i) const
{ return CProxySection_CkArrayMap::ckGetElements(i); }
inline int ckGetNumElements() const
{ return CProxySection_CkArrayMap::ckGetNumElements(); } 
inline int ckGetNumElements(int i) const
{ return CProxySection_CkArrayMap::ckGetNumElements(i); }
    void ckDelegate(CkDelegateMgr *dTo,CkDelegateData *dPtr=NULL) {
      CProxySection_CkArrayMap::ckDelegate(dTo,dPtr);
    }
    void ckUndelegate(void) {
      CProxySection_CkArrayMap::ckUndelegate();
    }
    void pup(PUP::er &p) {
      CProxySection_CkArrayMap::pup(p);
    }
    void ckSetGroupID(CkGroupID g) {
      CProxySection_CkArrayMap::ckSetGroupID(g);
    }
    LUBalancedSnakeMap* ckLocalBranch(void) const {
      return ckLocalBranch(ckGetGroupID());
    }
    static LUBalancedSnakeMap* ckLocalBranch(CkGroupID gID) {
      return (LUBalancedSnakeMap*)CkLocalBranch(gID);
    }
/* DECLS: LUBalancedSnakeMap(int impl_noname_4, int impl_noname_5);
 */

};
PUPmarshall(CProxySection_LUBalancedSnakeMap)
typedef CBaseT1<CkArrayMap, CProxy_LUBalancedSnakeMap> CBase_LUBalancedSnakeMap;

/* DECLS: group LUBalancedSnakeMap2: CkArrayMap{
LUBalancedSnakeMap2(int impl_noname_6, int impl_noname_7);
};
 */
 class LUBalancedSnakeMap2;
 class CkIndex_LUBalancedSnakeMap2;
 class CProxy_LUBalancedSnakeMap2;
 class CProxyElement_LUBalancedSnakeMap2;
 class CProxySection_LUBalancedSnakeMap2;
/* --------------- index object ------------------ */
class CkIndex_LUBalancedSnakeMap2:public CProxyElement_CkArrayMap{
  public:
    typedef LUBalancedSnakeMap2 local_t;
    typedef CkIndex_LUBalancedSnakeMap2 index_t;
    typedef CProxy_LUBalancedSnakeMap2 proxy_t;
    typedef CProxyElement_LUBalancedSnakeMap2 element_t;
    typedef CProxySection_LUBalancedSnakeMap2 section_t;

    static int __idx;
    static void __register(const char *s, size_t size);
/* DECLS: LUBalancedSnakeMap2(int impl_noname_6, int impl_noname_7);
 */
    static int __idx_LUBalancedSnakeMap2_marshall1;
    static int ckNew(int impl_noname_6, int impl_noname_7) { return __idx_LUBalancedSnakeMap2_marshall1; }
    static void _call_LUBalancedSnakeMap2_marshall1(void* impl_msg,LUBalancedSnakeMap2* impl_obj);
    static int _callmarshall_LUBalancedSnakeMap2_marshall1(char* impl_buf,LUBalancedSnakeMap2* impl_obj);
    static void _marshallmessagepup_LUBalancedSnakeMap2_marshall1(PUP::er &p,void *msg);

};
/* --------------- element proxy ------------------ */
class CProxyElement_LUBalancedSnakeMap2: public CProxyElement_CkArrayMap{
  public:
    typedef LUBalancedSnakeMap2 local_t;
    typedef CkIndex_LUBalancedSnakeMap2 index_t;
    typedef CProxy_LUBalancedSnakeMap2 proxy_t;
    typedef CProxyElement_LUBalancedSnakeMap2 element_t;
    typedef CProxySection_LUBalancedSnakeMap2 section_t;

    CProxyElement_LUBalancedSnakeMap2(void) {}
    CProxyElement_LUBalancedSnakeMap2(const IrrGroup *g) : CProxyElement_CkArrayMap(g){  }
    CProxyElement_LUBalancedSnakeMap2(CkGroupID _gid,int _onPE,CK_DELCTOR_PARAM) : CProxyElement_CkArrayMap(_gid,_onPE,CK_DELCTOR_ARGS){  }
    CProxyElement_LUBalancedSnakeMap2(CkGroupID _gid,int _onPE) : CProxyElement_CkArrayMap(_gid,_onPE){  }
int ckIsDelegated(void) const {return CProxyElement_CkArrayMap::ckIsDelegated();}
inline CkDelegateMgr *ckDelegatedTo(void) const {return CProxyElement_CkArrayMap::ckDelegatedTo();}
inline CkDelegateData *ckDelegatedPtr(void) const {return CProxyElement_CkArrayMap::ckDelegatedPtr();}
CkGroupID ckDelegatedIdx(void) const {return CProxyElement_CkArrayMap::ckDelegatedIdx();}
inline void ckCheck(void) const {CProxyElement_CkArrayMap::ckCheck();}
CkChareID ckGetChareID(void) const
   {return CProxyElement_CkArrayMap::ckGetChareID();}
CkGroupID ckGetGroupID(void) const
   {return CProxyElement_CkArrayMap::ckGetGroupID();}
operator CkGroupID () const { return ckGetGroupID(); }
inline void setReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxyElement_CkArrayMap::setReductionClient(fn,param); }
inline void ckSetReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxyElement_CkArrayMap::ckSetReductionClient(fn,param); }
inline void ckSetReductionClient(CkCallback *cb) const
{ CProxyElement_CkArrayMap::ckSetReductionClient(cb); }
int ckGetGroupPe(void) const
{return CProxyElement_CkArrayMap::ckGetGroupPe();}
    void ckDelegate(CkDelegateMgr *dTo,CkDelegateData *dPtr=NULL) {
      CProxyElement_CkArrayMap::ckDelegate(dTo,dPtr);
    }
    void ckUndelegate(void) {
      CProxyElement_CkArrayMap::ckUndelegate();
    }
    void pup(PUP::er &p) {
      CProxyElement_CkArrayMap::pup(p);
    }
    void ckSetGroupID(CkGroupID g) {
      CProxyElement_CkArrayMap::ckSetGroupID(g);
    }
    LUBalancedSnakeMap2* ckLocalBranch(void) const {
      return ckLocalBranch(ckGetGroupID());
    }
    static LUBalancedSnakeMap2* ckLocalBranch(CkGroupID gID) {
      return (LUBalancedSnakeMap2*)CkLocalBranch(gID);
    }
/* DECLS: LUBalancedSnakeMap2(int impl_noname_6, int impl_noname_7);
 */

};
PUPmarshall(CProxyElement_LUBalancedSnakeMap2)
/* ---------------- collective proxy -------------- */
class CProxy_LUBalancedSnakeMap2: public CProxy_CkArrayMap{
  public:
    typedef LUBalancedSnakeMap2 local_t;
    typedef CkIndex_LUBalancedSnakeMap2 index_t;
    typedef CProxy_LUBalancedSnakeMap2 proxy_t;
    typedef CProxyElement_LUBalancedSnakeMap2 element_t;
    typedef CProxySection_LUBalancedSnakeMap2 section_t;

    CProxy_LUBalancedSnakeMap2(void) {}
    CProxy_LUBalancedSnakeMap2(const IrrGroup *g) : CProxy_CkArrayMap(g){  }
    CProxy_LUBalancedSnakeMap2(CkGroupID _gid,CK_DELCTOR_PARAM) : CProxy_CkArrayMap(_gid,CK_DELCTOR_ARGS){  }
    CProxy_LUBalancedSnakeMap2(CkGroupID _gid) : CProxy_CkArrayMap(_gid){  }
    CProxyElement_LUBalancedSnakeMap2 operator[](int onPE) const
      {return CProxyElement_LUBalancedSnakeMap2(ckGetGroupID(),onPE,CK_DELCTOR_CALL);}
int ckIsDelegated(void) const {return CProxy_CkArrayMap::ckIsDelegated();}
inline CkDelegateMgr *ckDelegatedTo(void) const {return CProxy_CkArrayMap::ckDelegatedTo();}
inline CkDelegateData *ckDelegatedPtr(void) const {return CProxy_CkArrayMap::ckDelegatedPtr();}
CkGroupID ckDelegatedIdx(void) const {return CProxy_CkArrayMap::ckDelegatedIdx();}
inline void ckCheck(void) const {CProxy_CkArrayMap::ckCheck();}
CkChareID ckGetChareID(void) const
   {return CProxy_CkArrayMap::ckGetChareID();}
CkGroupID ckGetGroupID(void) const
   {return CProxy_CkArrayMap::ckGetGroupID();}
operator CkGroupID () const { return ckGetGroupID(); }
inline void setReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxy_CkArrayMap::setReductionClient(fn,param); }
inline void ckSetReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxy_CkArrayMap::ckSetReductionClient(fn,param); }
inline void ckSetReductionClient(CkCallback *cb) const
{ CProxy_CkArrayMap::ckSetReductionClient(cb); }
    void ckDelegate(CkDelegateMgr *dTo,CkDelegateData *dPtr=NULL) {
      CProxy_CkArrayMap::ckDelegate(dTo,dPtr);
    }
    void ckUndelegate(void) {
      CProxy_CkArrayMap::ckUndelegate();
    }
    void pup(PUP::er &p) {
      CProxy_CkArrayMap::pup(p);
    }
    void ckSetGroupID(CkGroupID g) {
      CProxy_CkArrayMap::ckSetGroupID(g);
    }
    LUBalancedSnakeMap2* ckLocalBranch(void) const {
      return ckLocalBranch(ckGetGroupID());
    }
    static LUBalancedSnakeMap2* ckLocalBranch(CkGroupID gID) {
      return (LUBalancedSnakeMap2*)CkLocalBranch(gID);
    }
/* DECLS: LUBalancedSnakeMap2(int impl_noname_6, int impl_noname_7);
 */
    static CkGroupID ckNew(int impl_noname_6, int impl_noname_7, const CkEntryOptions *impl_e_opts=NULL);
    CProxy_LUBalancedSnakeMap2(int impl_noname_6, int impl_noname_7, const CkEntryOptions *impl_e_opts=NULL);

};
PUPmarshall(CProxy_LUBalancedSnakeMap2)
/* ---------------- section proxy -------------- */
class CProxySection_LUBalancedSnakeMap2: public CProxySection_CkArrayMap{
  public:
    typedef LUBalancedSnakeMap2 local_t;
    typedef CkIndex_LUBalancedSnakeMap2 index_t;
    typedef CProxy_LUBalancedSnakeMap2 proxy_t;
    typedef CProxyElement_LUBalancedSnakeMap2 element_t;
    typedef CProxySection_LUBalancedSnakeMap2 section_t;

    CProxySection_LUBalancedSnakeMap2(void) {}
    CProxySection_LUBalancedSnakeMap2(const IrrGroup *g) : CProxySection_CkArrayMap(g){  }
    CProxySection_LUBalancedSnakeMap2(const CkGroupID &_gid,const int *_pelist,int _npes,CK_DELCTOR_PARAM) : CProxySection_CkArrayMap(_gid,_pelist,_npes,CK_DELCTOR_ARGS){  }
    CProxySection_LUBalancedSnakeMap2(const CkGroupID &_gid,const int *_pelist,int _npes) : CProxySection_CkArrayMap(_gid,_pelist,_npes){  }
    CProxySection_LUBalancedSnakeMap2(int n,const CkGroupID *_gid, int const * const *_pelist,const int *_npes) : CProxySection_CkArrayMap(n,_gid,_pelist,_npes){  }
    CProxySection_LUBalancedSnakeMap2(int n,const CkGroupID *_gid, int const * const *_pelist,const int *_npes,CK_DELCTOR_PARAM) : CProxySection_CkArrayMap(n,_gid,_pelist,_npes,CK_DELCTOR_ARGS){  }
int ckIsDelegated(void) const {return CProxySection_CkArrayMap::ckIsDelegated();}
inline CkDelegateMgr *ckDelegatedTo(void) const {return CProxySection_CkArrayMap::ckDelegatedTo();}
inline CkDelegateData *ckDelegatedPtr(void) const {return CProxySection_CkArrayMap::ckDelegatedPtr();}
CkGroupID ckDelegatedIdx(void) const {return CProxySection_CkArrayMap::ckDelegatedIdx();}
inline void ckCheck(void) const {CProxySection_CkArrayMap::ckCheck();}
CkChareID ckGetChareID(void) const
   {return CProxySection_CkArrayMap::ckGetChareID();}
CkGroupID ckGetGroupID(void) const
   {return CProxySection_CkArrayMap::ckGetGroupID();}
operator CkGroupID () const { return ckGetGroupID(); }
inline void setReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxySection_CkArrayMap::setReductionClient(fn,param); }
inline void ckSetReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxySection_CkArrayMap::ckSetReductionClient(fn,param); }
inline void ckSetReductionClient(CkCallback *cb) const
{ CProxySection_CkArrayMap::ckSetReductionClient(cb); }
inline int ckGetNumSections() const
{ return CProxySection_CkArrayMap::ckGetNumSections(); }
inline CkSectionInfo &ckGetSectionInfo()
{ return CProxySection_CkArrayMap::ckGetSectionInfo(); }
inline CkSectionID *ckGetSectionIDs()
{ return CProxySection_CkArrayMap::ckGetSectionIDs(); }
inline CkSectionID &ckGetSectionID()
{ return CProxySection_CkArrayMap::ckGetSectionID(); }
inline CkSectionID &ckGetSectionID(int i)
{ return CProxySection_CkArrayMap::ckGetSectionID(i); }
inline CkGroupID ckGetGroupIDn(int i) const
{ return CProxySection_CkArrayMap::ckGetGroupIDn(i); }
inline int *ckGetElements() const
{ return CProxySection_CkArrayMap::ckGetElements(); }
inline int *ckGetElements(int i) const
{ return CProxySection_CkArrayMap::ckGetElements(i); }
inline int ckGetNumElements() const
{ return CProxySection_CkArrayMap::ckGetNumElements(); } 
inline int ckGetNumElements(int i) const
{ return CProxySection_CkArrayMap::ckGetNumElements(i); }
    void ckDelegate(CkDelegateMgr *dTo,CkDelegateData *dPtr=NULL) {
      CProxySection_CkArrayMap::ckDelegate(dTo,dPtr);
    }
    void ckUndelegate(void) {
      CProxySection_CkArrayMap::ckUndelegate();
    }
    void pup(PUP::er &p) {
      CProxySection_CkArrayMap::pup(p);
    }
    void ckSetGroupID(CkGroupID g) {
      CProxySection_CkArrayMap::ckSetGroupID(g);
    }
    LUBalancedSnakeMap2* ckLocalBranch(void) const {
      return ckLocalBranch(ckGetGroupID());
    }
    static LUBalancedSnakeMap2* ckLocalBranch(CkGroupID gID) {
      return (LUBalancedSnakeMap2*)CkLocalBranch(gID);
    }
/* DECLS: LUBalancedSnakeMap2(int impl_noname_6, int impl_noname_7);
 */

};
PUPmarshall(CProxySection_LUBalancedSnakeMap2)
typedef CBaseT1<CkArrayMap, CProxy_LUBalancedSnakeMap2> CBase_LUBalancedSnakeMap2;

/* DECLS: group PE2DTilingMap: CkArrayMap{
PE2DTilingMap(int _peRows, int _peCols);
};
 */
 class PE2DTilingMap;
 class CkIndex_PE2DTilingMap;
 class CProxy_PE2DTilingMap;
 class CProxyElement_PE2DTilingMap;
 class CProxySection_PE2DTilingMap;
/* --------------- index object ------------------ */
class CkIndex_PE2DTilingMap:public CProxyElement_CkArrayMap{
  public:
    typedef PE2DTilingMap local_t;
    typedef CkIndex_PE2DTilingMap index_t;
    typedef CProxy_PE2DTilingMap proxy_t;
    typedef CProxyElement_PE2DTilingMap element_t;
    typedef CProxySection_PE2DTilingMap section_t;

    static int __idx;
    static void __register(const char *s, size_t size);
/* DECLS: PE2DTilingMap(int _peRows, int _peCols);
 */
    static int __idx_PE2DTilingMap_marshall1;
    static int ckNew(int _peRows, int _peCols) { return __idx_PE2DTilingMap_marshall1; }
    static void _call_PE2DTilingMap_marshall1(void* impl_msg,PE2DTilingMap* impl_obj);
    static int _callmarshall_PE2DTilingMap_marshall1(char* impl_buf,PE2DTilingMap* impl_obj);
    static void _marshallmessagepup_PE2DTilingMap_marshall1(PUP::er &p,void *msg);

};
/* --------------- element proxy ------------------ */
class CProxyElement_PE2DTilingMap: public CProxyElement_CkArrayMap{
  public:
    typedef PE2DTilingMap local_t;
    typedef CkIndex_PE2DTilingMap index_t;
    typedef CProxy_PE2DTilingMap proxy_t;
    typedef CProxyElement_PE2DTilingMap element_t;
    typedef CProxySection_PE2DTilingMap section_t;

    CProxyElement_PE2DTilingMap(void) {}
    CProxyElement_PE2DTilingMap(const IrrGroup *g) : CProxyElement_CkArrayMap(g){  }
    CProxyElement_PE2DTilingMap(CkGroupID _gid,int _onPE,CK_DELCTOR_PARAM) : CProxyElement_CkArrayMap(_gid,_onPE,CK_DELCTOR_ARGS){  }
    CProxyElement_PE2DTilingMap(CkGroupID _gid,int _onPE) : CProxyElement_CkArrayMap(_gid,_onPE){  }
int ckIsDelegated(void) const {return CProxyElement_CkArrayMap::ckIsDelegated();}
inline CkDelegateMgr *ckDelegatedTo(void) const {return CProxyElement_CkArrayMap::ckDelegatedTo();}
inline CkDelegateData *ckDelegatedPtr(void) const {return CProxyElement_CkArrayMap::ckDelegatedPtr();}
CkGroupID ckDelegatedIdx(void) const {return CProxyElement_CkArrayMap::ckDelegatedIdx();}
inline void ckCheck(void) const {CProxyElement_CkArrayMap::ckCheck();}
CkChareID ckGetChareID(void) const
   {return CProxyElement_CkArrayMap::ckGetChareID();}
CkGroupID ckGetGroupID(void) const
   {return CProxyElement_CkArrayMap::ckGetGroupID();}
operator CkGroupID () const { return ckGetGroupID(); }
inline void setReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxyElement_CkArrayMap::setReductionClient(fn,param); }
inline void ckSetReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxyElement_CkArrayMap::ckSetReductionClient(fn,param); }
inline void ckSetReductionClient(CkCallback *cb) const
{ CProxyElement_CkArrayMap::ckSetReductionClient(cb); }
int ckGetGroupPe(void) const
{return CProxyElement_CkArrayMap::ckGetGroupPe();}
    void ckDelegate(CkDelegateMgr *dTo,CkDelegateData *dPtr=NULL) {
      CProxyElement_CkArrayMap::ckDelegate(dTo,dPtr);
    }
    void ckUndelegate(void) {
      CProxyElement_CkArrayMap::ckUndelegate();
    }
    void pup(PUP::er &p) {
      CProxyElement_CkArrayMap::pup(p);
    }
    void ckSetGroupID(CkGroupID g) {
      CProxyElement_CkArrayMap::ckSetGroupID(g);
    }
    PE2DTilingMap* ckLocalBranch(void) const {
      return ckLocalBranch(ckGetGroupID());
    }
    static PE2DTilingMap* ckLocalBranch(CkGroupID gID) {
      return (PE2DTilingMap*)CkLocalBranch(gID);
    }
/* DECLS: PE2DTilingMap(int _peRows, int _peCols);
 */

};
PUPmarshall(CProxyElement_PE2DTilingMap)
/* ---------------- collective proxy -------------- */
class CProxy_PE2DTilingMap: public CProxy_CkArrayMap{
  public:
    typedef PE2DTilingMap local_t;
    typedef CkIndex_PE2DTilingMap index_t;
    typedef CProxy_PE2DTilingMap proxy_t;
    typedef CProxyElement_PE2DTilingMap element_t;
    typedef CProxySection_PE2DTilingMap section_t;

    CProxy_PE2DTilingMap(void) {}
    CProxy_PE2DTilingMap(const IrrGroup *g) : CProxy_CkArrayMap(g){  }
    CProxy_PE2DTilingMap(CkGroupID _gid,CK_DELCTOR_PARAM) : CProxy_CkArrayMap(_gid,CK_DELCTOR_ARGS){  }
    CProxy_PE2DTilingMap(CkGroupID _gid) : CProxy_CkArrayMap(_gid){  }
    CProxyElement_PE2DTilingMap operator[](int onPE) const
      {return CProxyElement_PE2DTilingMap(ckGetGroupID(),onPE,CK_DELCTOR_CALL);}
int ckIsDelegated(void) const {return CProxy_CkArrayMap::ckIsDelegated();}
inline CkDelegateMgr *ckDelegatedTo(void) const {return CProxy_CkArrayMap::ckDelegatedTo();}
inline CkDelegateData *ckDelegatedPtr(void) const {return CProxy_CkArrayMap::ckDelegatedPtr();}
CkGroupID ckDelegatedIdx(void) const {return CProxy_CkArrayMap::ckDelegatedIdx();}
inline void ckCheck(void) const {CProxy_CkArrayMap::ckCheck();}
CkChareID ckGetChareID(void) const
   {return CProxy_CkArrayMap::ckGetChareID();}
CkGroupID ckGetGroupID(void) const
   {return CProxy_CkArrayMap::ckGetGroupID();}
operator CkGroupID () const { return ckGetGroupID(); }
inline void setReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxy_CkArrayMap::setReductionClient(fn,param); }
inline void ckSetReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxy_CkArrayMap::ckSetReductionClient(fn,param); }
inline void ckSetReductionClient(CkCallback *cb) const
{ CProxy_CkArrayMap::ckSetReductionClient(cb); }
    void ckDelegate(CkDelegateMgr *dTo,CkDelegateData *dPtr=NULL) {
      CProxy_CkArrayMap::ckDelegate(dTo,dPtr);
    }
    void ckUndelegate(void) {
      CProxy_CkArrayMap::ckUndelegate();
    }
    void pup(PUP::er &p) {
      CProxy_CkArrayMap::pup(p);
    }
    void ckSetGroupID(CkGroupID g) {
      CProxy_CkArrayMap::ckSetGroupID(g);
    }
    PE2DTilingMap* ckLocalBranch(void) const {
      return ckLocalBranch(ckGetGroupID());
    }
    static PE2DTilingMap* ckLocalBranch(CkGroupID gID) {
      return (PE2DTilingMap*)CkLocalBranch(gID);
    }
/* DECLS: PE2DTilingMap(int _peRows, int _peCols);
 */
    static CkGroupID ckNew(int _peRows, int _peCols, const CkEntryOptions *impl_e_opts=NULL);
    CProxy_PE2DTilingMap(int _peRows, int _peCols, const CkEntryOptions *impl_e_opts=NULL);

};
PUPmarshall(CProxy_PE2DTilingMap)
/* ---------------- section proxy -------------- */
class CProxySection_PE2DTilingMap: public CProxySection_CkArrayMap{
  public:
    typedef PE2DTilingMap local_t;
    typedef CkIndex_PE2DTilingMap index_t;
    typedef CProxy_PE2DTilingMap proxy_t;
    typedef CProxyElement_PE2DTilingMap element_t;
    typedef CProxySection_PE2DTilingMap section_t;

    CProxySection_PE2DTilingMap(void) {}
    CProxySection_PE2DTilingMap(const IrrGroup *g) : CProxySection_CkArrayMap(g){  }
    CProxySection_PE2DTilingMap(const CkGroupID &_gid,const int *_pelist,int _npes,CK_DELCTOR_PARAM) : CProxySection_CkArrayMap(_gid,_pelist,_npes,CK_DELCTOR_ARGS){  }
    CProxySection_PE2DTilingMap(const CkGroupID &_gid,const int *_pelist,int _npes) : CProxySection_CkArrayMap(_gid,_pelist,_npes){  }
    CProxySection_PE2DTilingMap(int n,const CkGroupID *_gid, int const * const *_pelist,const int *_npes) : CProxySection_CkArrayMap(n,_gid,_pelist,_npes){  }
    CProxySection_PE2DTilingMap(int n,const CkGroupID *_gid, int const * const *_pelist,const int *_npes,CK_DELCTOR_PARAM) : CProxySection_CkArrayMap(n,_gid,_pelist,_npes,CK_DELCTOR_ARGS){  }
int ckIsDelegated(void) const {return CProxySection_CkArrayMap::ckIsDelegated();}
inline CkDelegateMgr *ckDelegatedTo(void) const {return CProxySection_CkArrayMap::ckDelegatedTo();}
inline CkDelegateData *ckDelegatedPtr(void) const {return CProxySection_CkArrayMap::ckDelegatedPtr();}
CkGroupID ckDelegatedIdx(void) const {return CProxySection_CkArrayMap::ckDelegatedIdx();}
inline void ckCheck(void) const {CProxySection_CkArrayMap::ckCheck();}
CkChareID ckGetChareID(void) const
   {return CProxySection_CkArrayMap::ckGetChareID();}
CkGroupID ckGetGroupID(void) const
   {return CProxySection_CkArrayMap::ckGetGroupID();}
operator CkGroupID () const { return ckGetGroupID(); }
inline void setReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxySection_CkArrayMap::setReductionClient(fn,param); }
inline void ckSetReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxySection_CkArrayMap::ckSetReductionClient(fn,param); }
inline void ckSetReductionClient(CkCallback *cb) const
{ CProxySection_CkArrayMap::ckSetReductionClient(cb); }
inline int ckGetNumSections() const
{ return CProxySection_CkArrayMap::ckGetNumSections(); }
inline CkSectionInfo &ckGetSectionInfo()
{ return CProxySection_CkArrayMap::ckGetSectionInfo(); }
inline CkSectionID *ckGetSectionIDs()
{ return CProxySection_CkArrayMap::ckGetSectionIDs(); }
inline CkSectionID &ckGetSectionID()
{ return CProxySection_CkArrayMap::ckGetSectionID(); }
inline CkSectionID &ckGetSectionID(int i)
{ return CProxySection_CkArrayMap::ckGetSectionID(i); }
inline CkGroupID ckGetGroupIDn(int i) const
{ return CProxySection_CkArrayMap::ckGetGroupIDn(i); }
inline int *ckGetElements() const
{ return CProxySection_CkArrayMap::ckGetElements(); }
inline int *ckGetElements(int i) const
{ return CProxySection_CkArrayMap::ckGetElements(i); }
inline int ckGetNumElements() const
{ return CProxySection_CkArrayMap::ckGetNumElements(); } 
inline int ckGetNumElements(int i) const
{ return CProxySection_CkArrayMap::ckGetNumElements(i); }
    void ckDelegate(CkDelegateMgr *dTo,CkDelegateData *dPtr=NULL) {
      CProxySection_CkArrayMap::ckDelegate(dTo,dPtr);
    }
    void ckUndelegate(void) {
      CProxySection_CkArrayMap::ckUndelegate();
    }
    void pup(PUP::er &p) {
      CProxySection_CkArrayMap::pup(p);
    }
    void ckSetGroupID(CkGroupID g) {
      CProxySection_CkArrayMap::ckSetGroupID(g);
    }
    PE2DTilingMap* ckLocalBranch(void) const {
      return ckLocalBranch(ckGetGroupID());
    }
    static PE2DTilingMap* ckLocalBranch(CkGroupID gID) {
      return (PE2DTilingMap*)CkLocalBranch(gID);
    }
/* DECLS: PE2DTilingMap(int _peRows, int _peCols);
 */

};
PUPmarshall(CProxySection_PE2DTilingMap)
typedef CBaseT1<CkArrayMap, CProxy_PE2DTilingMap> CBase_PE2DTilingMap;

/* DECLS: group StrongScaling1: CkArrayMap{
StrongScaling1(int numBlks_);
};
 */
 class StrongScaling1;
 class CkIndex_StrongScaling1;
 class CProxy_StrongScaling1;
 class CProxyElement_StrongScaling1;
 class CProxySection_StrongScaling1;
/* --------------- index object ------------------ */
class CkIndex_StrongScaling1:public CProxyElement_CkArrayMap{
  public:
    typedef StrongScaling1 local_t;
    typedef CkIndex_StrongScaling1 index_t;
    typedef CProxy_StrongScaling1 proxy_t;
    typedef CProxyElement_StrongScaling1 element_t;
    typedef CProxySection_StrongScaling1 section_t;

    static int __idx;
    static void __register(const char *s, size_t size);
/* DECLS: StrongScaling1(int numBlks_);
 */
    static int __idx_StrongScaling1_marshall1;
    static int ckNew(int numBlks_) { return __idx_StrongScaling1_marshall1; }
    static void _call_StrongScaling1_marshall1(void* impl_msg,StrongScaling1* impl_obj);
    static int _callmarshall_StrongScaling1_marshall1(char* impl_buf,StrongScaling1* impl_obj);
    static void _marshallmessagepup_StrongScaling1_marshall1(PUP::er &p,void *msg);

};
/* --------------- element proxy ------------------ */
class CProxyElement_StrongScaling1: public CProxyElement_CkArrayMap{
  public:
    typedef StrongScaling1 local_t;
    typedef CkIndex_StrongScaling1 index_t;
    typedef CProxy_StrongScaling1 proxy_t;
    typedef CProxyElement_StrongScaling1 element_t;
    typedef CProxySection_StrongScaling1 section_t;

    CProxyElement_StrongScaling1(void) {}
    CProxyElement_StrongScaling1(const IrrGroup *g) : CProxyElement_CkArrayMap(g){  }
    CProxyElement_StrongScaling1(CkGroupID _gid,int _onPE,CK_DELCTOR_PARAM) : CProxyElement_CkArrayMap(_gid,_onPE,CK_DELCTOR_ARGS){  }
    CProxyElement_StrongScaling1(CkGroupID _gid,int _onPE) : CProxyElement_CkArrayMap(_gid,_onPE){  }
int ckIsDelegated(void) const {return CProxyElement_CkArrayMap::ckIsDelegated();}
inline CkDelegateMgr *ckDelegatedTo(void) const {return CProxyElement_CkArrayMap::ckDelegatedTo();}
inline CkDelegateData *ckDelegatedPtr(void) const {return CProxyElement_CkArrayMap::ckDelegatedPtr();}
CkGroupID ckDelegatedIdx(void) const {return CProxyElement_CkArrayMap::ckDelegatedIdx();}
inline void ckCheck(void) const {CProxyElement_CkArrayMap::ckCheck();}
CkChareID ckGetChareID(void) const
   {return CProxyElement_CkArrayMap::ckGetChareID();}
CkGroupID ckGetGroupID(void) const
   {return CProxyElement_CkArrayMap::ckGetGroupID();}
operator CkGroupID () const { return ckGetGroupID(); }
inline void setReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxyElement_CkArrayMap::setReductionClient(fn,param); }
inline void ckSetReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxyElement_CkArrayMap::ckSetReductionClient(fn,param); }
inline void ckSetReductionClient(CkCallback *cb) const
{ CProxyElement_CkArrayMap::ckSetReductionClient(cb); }
int ckGetGroupPe(void) const
{return CProxyElement_CkArrayMap::ckGetGroupPe();}
    void ckDelegate(CkDelegateMgr *dTo,CkDelegateData *dPtr=NULL) {
      CProxyElement_CkArrayMap::ckDelegate(dTo,dPtr);
    }
    void ckUndelegate(void) {
      CProxyElement_CkArrayMap::ckUndelegate();
    }
    void pup(PUP::er &p) {
      CProxyElement_CkArrayMap::pup(p);
    }
    void ckSetGroupID(CkGroupID g) {
      CProxyElement_CkArrayMap::ckSetGroupID(g);
    }
    StrongScaling1* ckLocalBranch(void) const {
      return ckLocalBranch(ckGetGroupID());
    }
    static StrongScaling1* ckLocalBranch(CkGroupID gID) {
      return (StrongScaling1*)CkLocalBranch(gID);
    }
/* DECLS: StrongScaling1(int numBlks_);
 */

};
PUPmarshall(CProxyElement_StrongScaling1)
/* ---------------- collective proxy -------------- */
class CProxy_StrongScaling1: public CProxy_CkArrayMap{
  public:
    typedef StrongScaling1 local_t;
    typedef CkIndex_StrongScaling1 index_t;
    typedef CProxy_StrongScaling1 proxy_t;
    typedef CProxyElement_StrongScaling1 element_t;
    typedef CProxySection_StrongScaling1 section_t;

    CProxy_StrongScaling1(void) {}
    CProxy_StrongScaling1(const IrrGroup *g) : CProxy_CkArrayMap(g){  }
    CProxy_StrongScaling1(CkGroupID _gid,CK_DELCTOR_PARAM) : CProxy_CkArrayMap(_gid,CK_DELCTOR_ARGS){  }
    CProxy_StrongScaling1(CkGroupID _gid) : CProxy_CkArrayMap(_gid){  }
    CProxyElement_StrongScaling1 operator[](int onPE) const
      {return CProxyElement_StrongScaling1(ckGetGroupID(),onPE,CK_DELCTOR_CALL);}
int ckIsDelegated(void) const {return CProxy_CkArrayMap::ckIsDelegated();}
inline CkDelegateMgr *ckDelegatedTo(void) const {return CProxy_CkArrayMap::ckDelegatedTo();}
inline CkDelegateData *ckDelegatedPtr(void) const {return CProxy_CkArrayMap::ckDelegatedPtr();}
CkGroupID ckDelegatedIdx(void) const {return CProxy_CkArrayMap::ckDelegatedIdx();}
inline void ckCheck(void) const {CProxy_CkArrayMap::ckCheck();}
CkChareID ckGetChareID(void) const
   {return CProxy_CkArrayMap::ckGetChareID();}
CkGroupID ckGetGroupID(void) const
   {return CProxy_CkArrayMap::ckGetGroupID();}
operator CkGroupID () const { return ckGetGroupID(); }
inline void setReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxy_CkArrayMap::setReductionClient(fn,param); }
inline void ckSetReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxy_CkArrayMap::ckSetReductionClient(fn,param); }
inline void ckSetReductionClient(CkCallback *cb) const
{ CProxy_CkArrayMap::ckSetReductionClient(cb); }
    void ckDelegate(CkDelegateMgr *dTo,CkDelegateData *dPtr=NULL) {
      CProxy_CkArrayMap::ckDelegate(dTo,dPtr);
    }
    void ckUndelegate(void) {
      CProxy_CkArrayMap::ckUndelegate();
    }
    void pup(PUP::er &p) {
      CProxy_CkArrayMap::pup(p);
    }
    void ckSetGroupID(CkGroupID g) {
      CProxy_CkArrayMap::ckSetGroupID(g);
    }
    StrongScaling1* ckLocalBranch(void) const {
      return ckLocalBranch(ckGetGroupID());
    }
    static StrongScaling1* ckLocalBranch(CkGroupID gID) {
      return (StrongScaling1*)CkLocalBranch(gID);
    }
/* DECLS: StrongScaling1(int numBlks_);
 */
    static CkGroupID ckNew(int numBlks_, const CkEntryOptions *impl_e_opts=NULL);
    CProxy_StrongScaling1(int numBlks_, const CkEntryOptions *impl_e_opts=NULL);

};
PUPmarshall(CProxy_StrongScaling1)
/* ---------------- section proxy -------------- */
class CProxySection_StrongScaling1: public CProxySection_CkArrayMap{
  public:
    typedef StrongScaling1 local_t;
    typedef CkIndex_StrongScaling1 index_t;
    typedef CProxy_StrongScaling1 proxy_t;
    typedef CProxyElement_StrongScaling1 element_t;
    typedef CProxySection_StrongScaling1 section_t;

    CProxySection_StrongScaling1(void) {}
    CProxySection_StrongScaling1(const IrrGroup *g) : CProxySection_CkArrayMap(g){  }
    CProxySection_StrongScaling1(const CkGroupID &_gid,const int *_pelist,int _npes,CK_DELCTOR_PARAM) : CProxySection_CkArrayMap(_gid,_pelist,_npes,CK_DELCTOR_ARGS){  }
    CProxySection_StrongScaling1(const CkGroupID &_gid,const int *_pelist,int _npes) : CProxySection_CkArrayMap(_gid,_pelist,_npes){  }
    CProxySection_StrongScaling1(int n,const CkGroupID *_gid, int const * const *_pelist,const int *_npes) : CProxySection_CkArrayMap(n,_gid,_pelist,_npes){  }
    CProxySection_StrongScaling1(int n,const CkGroupID *_gid, int const * const *_pelist,const int *_npes,CK_DELCTOR_PARAM) : CProxySection_CkArrayMap(n,_gid,_pelist,_npes,CK_DELCTOR_ARGS){  }
int ckIsDelegated(void) const {return CProxySection_CkArrayMap::ckIsDelegated();}
inline CkDelegateMgr *ckDelegatedTo(void) const {return CProxySection_CkArrayMap::ckDelegatedTo();}
inline CkDelegateData *ckDelegatedPtr(void) const {return CProxySection_CkArrayMap::ckDelegatedPtr();}
CkGroupID ckDelegatedIdx(void) const {return CProxySection_CkArrayMap::ckDelegatedIdx();}
inline void ckCheck(void) const {CProxySection_CkArrayMap::ckCheck();}
CkChareID ckGetChareID(void) const
   {return CProxySection_CkArrayMap::ckGetChareID();}
CkGroupID ckGetGroupID(void) const
   {return CProxySection_CkArrayMap::ckGetGroupID();}
operator CkGroupID () const { return ckGetGroupID(); }
inline void setReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxySection_CkArrayMap::setReductionClient(fn,param); }
inline void ckSetReductionClient(CkReductionClientFn fn,void *param=NULL) const
{ CProxySection_CkArrayMap::ckSetReductionClient(fn,param); }
inline void ckSetReductionClient(CkCallback *cb) const
{ CProxySection_CkArrayMap::ckSetReductionClient(cb); }
inline int ckGetNumSections() const
{ return CProxySection_CkArrayMap::ckGetNumSections(); }
inline CkSectionInfo &ckGetSectionInfo()
{ return CProxySection_CkArrayMap::ckGetSectionInfo(); }
inline CkSectionID *ckGetSectionIDs()
{ return CProxySection_CkArrayMap::ckGetSectionIDs(); }
inline CkSectionID &ckGetSectionID()
{ return CProxySection_CkArrayMap::ckGetSectionID(); }
inline CkSectionID &ckGetSectionID(int i)
{ return CProxySection_CkArrayMap::ckGetSectionID(i); }
inline CkGroupID ckGetGroupIDn(int i) const
{ return CProxySection_CkArrayMap::ckGetGroupIDn(i); }
inline int *ckGetElements() const
{ return CProxySection_CkArrayMap::ckGetElements(); }
inline int *ckGetElements(int i) const
{ return CProxySection_CkArrayMap::ckGetElements(i); }
inline int ckGetNumElements() const
{ return CProxySection_CkArrayMap::ckGetNumElements(); } 
inline int ckGetNumElements(int i) const
{ return CProxySection_CkArrayMap::ckGetNumElements(i); }
    void ckDelegate(CkDelegateMgr *dTo,CkDelegateData *dPtr=NULL) {
      CProxySection_CkArrayMap::ckDelegate(dTo,dPtr);
    }
    void ckUndelegate(void) {
      CProxySection_CkArrayMap::ckUndelegate();
    }
    void pup(PUP::er &p) {
      CProxySection_CkArrayMap::pup(p);
    }
    void ckSetGroupID(CkGroupID g) {
      CProxySection_CkArrayMap::ckSetGroupID(g);
    }
    StrongScaling1* ckLocalBranch(void) const {
      return ckLocalBranch(ckGetGroupID());
    }
    static StrongScaling1* ckLocalBranch(CkGroupID gID) {
      return (StrongScaling1*)CkLocalBranch(gID);
    }
/* DECLS: StrongScaling1(int numBlks_);
 */

};
PUPmarshall(CProxySection_StrongScaling1)
typedef CBaseT1<CkArrayMap, CProxy_StrongScaling1> CBase_StrongScaling1;

extern void _registerlu(void);
extern "C" void CkRegisterMainModule(void);
#endif
